<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Fluenta Tempus - Magnifico Timeline</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font: 13px system-ui; background: #fff; }

.chart {
  background: #fff;
  overflow-x: auto;
  overflow-y: auto;
  position: relative;
  height: 100%; /* Force container height */
  min-width: 0; /* MAGNIFICO! Force Grid item to respect overflow! */
}

.chart-scroll {
  position: relative;
  display: inline-block;
  min-width: 100%;
}

.task {
  display: flex;
  align-items: center;
  padding: 8px 8px 8px 4px;
  background: #fff;
  border-bottom: 1px solid #e0e0e0;
  height: 48px;
  gap: 4px;
  position: relative;
}

.task.indent-1 {
  padding-left: 28px;
  background: #fafafa;
}

.task.indent-1 .task-name {
  font-size: 12px;
  font-weight: 500;
}

.task.indent-1::before {
  content: "";
  position: absolute;
  left: 12px;
  top: 50%;
  width: 16px;
  height: 1px;
  background: #ddd;
}

/* Hide subtasks when parent is collapsed */
.task.collapsed + .task.indent-1,
.task.collapsed ~ .task.indent-1 {
  display: none;
}

.task:hover {
  background: #f8f9fa;
}

.task.dragging {
  opacity: 0.5;
  background: #e3f2fd;
}

/* Main Grid Layout */
.app {
  display: grid;
  grid-template-columns: 320px 1fr;
  grid-template-rows: auto auto 1fr;
  height: calc(100vh - 48px); /* Space for team bar */
  overflow: hidden;
}

/* Header spans both columns */
.header {
  grid-column: 1 / -1;
  padding: 16px;
  background: #000;
  color: #fff;
  border-bottom: 1px solid #ddd;
}

.header h1 { font-size: 18px; }
.header .subtitle { opacity: 0.7; font-size: 11px; margin-top: 4px; }

/* Controls in left column - SAME HEIGHT AS TIMELINE! */
.controls {
  height: 48px; /* MAGNIFICO! Perfect alignment! */
  padding: 0 8px; /* Only horizontal padding */
  background: #f8f8f8;
  border-bottom: 1px solid #ddd;
  display: flex;
  align-items: center; /* Center buttons vertically */
  gap: 8px;
}

/* Team bar - MINIMAL & ELEGANT! */
.team-bar {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  height: 48px;
  background: #f8f8f8;
  border-top: 2px solid #ddd;
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 0 16px;
  z-index: 50;
}

.team-label {
  font-weight: 600;
  font-size: 12px;
  text-transform: uppercase;
  color: #666;
}

.team-members {
  display: flex;
  gap: 6px;
  flex: 1;
  flex-wrap: wrap;
  align-items: center;
}

.resource-badge {
  color: #fff;
  padding: 4px 8px;
  border-radius: 3px;
  font-size: 11px;
  font-weight: 600;
  cursor: pointer;
  position: relative;
  transition: all 0.2s;
  white-space: nowrap;
  border: 1px solid transparent;
}

.resource-badge:hover {
  transform: translateY(-2px);
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  filter: brightness(1.1);
  border: 1px solid rgba(255,255,255,0.3);
}

.resource-delete-inline {
  position: absolute;
  top: -8px;
  right: -8px;
  width: 18px;
  height: 18px;
  background: #ff4444;
  color: #fff;
  border-radius: 50%;
  display: none;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  cursor: pointer;
  z-index: 5;
  border: 1px solid #fff;
}

.resource-badge:hover .resource-delete-inline {
  display: flex;
}

.resource-delete-inline:hover {
  background: #cc0000;
  transform: scale(1.1);
}

.add-resource-btn {
  padding: 4px 12px;
  background: #fff;
  border: 1px dashed #999;
  border-radius: 3px;
  cursor: pointer;
  font-size: 11px;
  color: #666;
  transition: all 0.2s;
}

.add-resource-btn:hover {
  background: #000;
  color: #fff;
  border-color: #000;
  border-style: solid;
}

/* Timeline header - MAGNIFICO VERSION! */
.timeline-header {
  background: #f8f8f8;
  border-bottom: 1px solid #ddd;
  border-left: 1px solid #ddd;
  overflow: hidden; /* NO SCROLLBAR! Chart controls it! */
  display: flex;
  height: 48px;
  position: relative;
}

.timeline-scroll {
  display: flex;
  position: relative;
  padding-top: 12px; /* Space for month labels */
  transition: transform 0ms; /* Smooth scroll sync */
}

/* Each day gets its own column - GENIAL! */
.day {
  width: 20px; /* 20px per day - PERFEKT! */
  height: 36px; /* Slightly shorter to make room for month */
  border-right: 1px solid #f0f0f0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  position: relative;
  flex-shrink: 0;
}

.day.weekend {
  background: #f5f5f5;
  color: #999;
}

.day.week-start {
  border-left: 2px solid #ddd;
}

.day.month-start {
  border-left: 2px solid #333;
}

.day-number {
  font-weight: 600;
  line-height: 1;
}

.day-name {
  font-size: 8px;
  opacity: 0.5;
  margin-top: 2px;
}

/* Month labels - subtle and elegant! */
.month-label {
  position: absolute;
  top: 0;
  height: 12px;
  display: flex;
  align-items: center;
  font-size: 10px;
  font-weight: 600;
  color: #666;
  padding: 0 4px;
  pointer-events: none;
  z-index: 5;
}

/* Month separator lines - subtle! */
.month-line {
  position: absolute;
  top: 10px;
  bottom: 0;
  width: 1px;
  background: #333;
  pointer-events: none;
  z-index: 4;
}

/* Main content area with synchronized grids */
.content {
  grid-column: 1 / -1;
  display: grid;
  grid-template-columns: 320px 1fr;
  overflow: hidden; /* Keep for vertical sync, but chart handles its own overflow */
  height: 100%; /* Take remaining space in grid */
}

/* Task list - no own scrollbar but scrollable via JS */
.task-list {
  display: grid;
  grid-auto-rows: 48px;
  overflow: hidden; /* NO visible scrollbars! */
}

/* Collapse/Expand toggle - SEPARATE from drag handle! */
.collapse-toggle {
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #666;
  flex-shrink: 0;
  border-radius: 3px;
  transition: all 0.2s;
  user-select: none;
}

.collapse-toggle:hover {
  background: #f0f0f0;
  color: #000;
}

.collapse-toggle.collapsed {
  transform: rotate(-90deg);
}

/* Empty space for tasks without children */
.collapse-toggle.empty {
  cursor: default;
  opacity: 0;
  pointer-events: none;
}

/* Drag handle - ONLY this is draggable! */
.drag-handle {
  width: 20px;
  height: 32px;
  cursor: move;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #999;
  flex-shrink: 0;
}

.drag-handle:hover {
  color: #333;
  background: #f0f0f0;
  border-radius: 4px;
}

/* Task content - editable! */
.task-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  min-width: 0;
  position: relative; /* For indent controls */
}

/* First line: name on left, actions on right */
.task-top {
  display: flex;
  align-items: center;
  gap: 8px;
}

.task-top .task-name { flex: 1; }

/* Indent/Outdent button - ONE BUTTON TO RULE THEM ALL! */
.indent-controls {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  display: none;
}

/* Actions appear on hover to keep it clean */
.task-actions { display: none; gap: 6px; }
.task:hover .task-actions { display: inline-flex; }

.indent-btn {
  width: 24px;
  height: 24px;
  background: #fff;
  border: 1px solid #ddd;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  color: #666;
  padding: 0;
  transition: all 0.2s;
}

.indent-btn:hover {
  background: #2196F3;
  border-color: #2196F3;
  color: #fff;
  transform: scale(1.1);
  box-shadow: 0 2px 4px rgba(33, 150, 243, 0.3);
}

/* Delete button matches indent control size, warns on hover */
.delete-btn { margin-left: 6px; }
.delete-btn:hover {
  background: #ff4444;
  border-color: #ff4444;
  color: #fff;
  box-shadow: 0 2px 4px rgba(255, 68, 68, 0.3);
}

.task-name {
  font-weight: 600;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  padding: 2px 4px;
  border-radius: 2px;
  cursor: text;
}

.task-name:hover {
  background: #f0f0f0;
}

.task-name.editing {
  background: #fff;
  border: 2px solid #2196F3;
  outline: none;
  overflow: visible;
  white-space: normal;
}

.task-meta {
  display: flex;
  gap: 8px;
  align-items: center;
  font-size: 11px;
  margin-top: 2px;
}

.owner {
  color: #fff;
  padding: 2px 6px;
  border-radius: 2px;
  cursor: pointer;
  font-weight: 600;
  font-size: 11px;
  transition: all 0.2s;
}

.owner:hover {
  filter: brightness(1.2);
  transform: scale(1.05);
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.duration {
  cursor: pointer;
  padding: 1px 4px;
  border-radius: 2px;
}

.duration:hover {
  background: #f0f0f0;
}

.progress-badge {
  cursor: pointer;
  padding: 1px 4px;
  border-radius: 2px;
}

.progress-badge:hover {
  background: #f0f0f0;
}

.deps-badge {
  cursor: pointer;
  padding: 2px 6px;
  border-radius: 2px;
  color: #666;
  font-size: 11px;
  margin-left: 4px;
}

.deps-badge:hover {
  background: #e3f2fd;
  color: #1976D2;
}

.deps-badge.has-deps {
  background: #f0f0f0;
  color: #333;
  border: 1px solid #ddd;
}

.deps-badge.blocked {
  background: #ffebee;
  color: #c62828;
  border: 1px solid #ffcdd2;
  font-weight: 600;
}

.chart-row {
  position: relative;
  border-bottom: 1px solid #f0f0f0;
  height: 48px; /* Explicit height matching grid */
}

/* Parent task rows - visual separator */
.chart-row.parent {
  background: linear-gradient(to bottom, #f8f8f8 0%, #fff 100%);
  border-bottom: 2px solid #e0e0e0;
}

.bar {
  position: absolute;
  top: 10px;
  height: 28px;
  border-radius: 4px;
  display: flex;
  align-items: center;
  padding: 0 8px;
  color: #fff;
  font-size: 11px;
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.bar:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
  z-index: 5;
}

/* Bar colors now come from resource.color dynamically! */

.progress {
  position: absolute;
  bottom: 0;
  left: 0;
  height: 3px;
  background: #4CAF50; /* GR√úN! Das universelle Symbol f√ºr FERTIG! */
  border-radius: 0 0 4px 4px;
  transition: width 0.3s ease; /* Smooth animation when progress changes */
}

/* Today marker - because we care about NOW */
.today-marker {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 2px;
  background: #ff4444;
  pointer-events: none;
  z-index: 15;
  box-shadow: 0 0 4px rgba(255, 68, 68, 0.5);
}

/* Controls - MINIMAL ICON BUTTONS! */
.controls button {
  padding: 6px;
  background: transparent; /* MAGNIFICO! Icons speak for themselves! */
  color: #333;
  border: 0;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px; /* Slightly smaller icons */
  width: 32px; /* Compact! */
  height: 32px; /* Perfect fit in 48px container */
  display: inline-flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}

.controls button:hover {
  background: #f0f0f0;
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* Modal buttons still need background */
button {
  padding: 8px;
  background: #000;
  color: #fff;
  border: 0;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  width: 40px;
  height: 40px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}

button:hover {
  background: #333;
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

/* Make scrollbars thin */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: #f1f1f1;
}

::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #555;
}

/* Drop zones for subtasks - visual feedback! */
.task.drop-forbidden {
  opacity: 0.3;
  pointer-events: none;
}

.task.drop-forbidden::after {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: repeating-linear-gradient(
    45deg,
    transparent,
    transparent 10px,
    rgba(255,0,0,0.05) 10px,
    rgba(255,0,0,0.05) 20px
  );
}

.task-list {
  background: #f8f8f8;
  border-right: 1px solid #ddd;
}

/* Modal - MINIMAL aber ELEGANT! */
.modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.5);
  z-index: 100;
  align-items: center;
  justify-content: center;
}

.modal.active {
  display: flex;
}

.modal-content {
  background: #fff;
  border-radius: 8px;
  padding: 24px;
  min-width: 400px;
  max-width: 500px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.2);
}

.modal-header {
  margin-bottom: 16px;
}

.modal-header h3 {
  font-size: 18px;
  margin: 0;
}

.modal-header .task-title {
  color: #666;
  font-size: 14px;
  margin-top: 4px;
}

.deps-selector {
  margin: 16px 0;
}

.deps-list {
  border: 1px solid #ddd;
  border-radius: 4px;
  max-height: 200px;
  overflow-y: auto;
  padding: 8px;
  background: #fafafa;
}

.dep-option {
  padding: 8px;
  margin-bottom: 4px;
  border-radius: 4px;
  cursor: pointer;
  background: #fff;
  border: 1px solid #e0e0e0;
  display: flex;
  align-items: center;
  gap: 8px;
}

.dep-option:hover {
  background: #e3f2fd;
  border-color: #2196F3;
}

.dep-option.selected {
  background: #2196F3;
  color: #fff;
  border-color: #1976D2;
}

.dep-option input[type="checkbox"] {
  margin: 0;
}

.dep-option .task-name {
  flex: 1;
  font-weight: 500;
}

.modal-footer {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
  margin-top: 24px;
}

.modal-footer button {
  padding: 8px 20px;
  min-width: 80px; /* Modal buttons etwas kleiner */
}

.btn-cancel {
  background: #666;
}

.btn-cancel:hover {
  background: #999;
}

.current-deps {
  margin-top: 8px;
  padding: 8px;
  background: #f0f0f0;
  border-radius: 4px;
  font-size: 12px;
  color: #666;
}

/* Link badge for parent tasks */
.link-badge {
  cursor: pointer;
  padding: 2px 6px;
  border-radius: 2px;
  font-size: 11px;
  margin-left: 4px;
  color: #1976D2;
  text-decoration: none;
  display: inline-flex;
  align-items: center;
  gap: 4px;
}

.link-badge:hover {
  background: #e3f2fd;
  text-decoration: underline;
}

.link-badge.empty {
  color: #999;
  border: 1px solid #ddd;
  background: #fafafa;
}

.link-badge.empty:hover {
  background: #fff;
  border-color: #1976D2;
  color: #1976D2;
}
</style>
</head>
<body>

<div class="app">
  <div class="header">
    <h1>Fluenta Tempus</h1>
    <div class="subtitle">Magnifico Timeline - 20px per Day!</div>
  </div>
  
  <div class="controls">
    <button onclick="addTask()" title="Add new task">‚ûï</button>
    <button onclick="exportJSON()" title="Export project">üíæ</button>
    <button onclick="importJSON()" title="Import project">üìÅ</button>
    <button onclick="editStartDate()" id="startDateBtn" title="Project start: Loading...">üìÖ</button>
  </div>
  
  <div class="timeline-header" id="timeline"></div>
  
  <div class="content">
    <div class="task-list" id="taskList"></div>
    <div class="chart" id="chart"></div>
  </div>
</div>

<!-- Team Bar - ONE LINE TO RULE THEM ALL! -->
<div class="team-bar">
  <span class="team-label">Team:</span>
  <div class="team-members" id="teamMembers">
    <!-- Resource badges will be rendered here -->
  </div>
  <div class="add-resource-btn" onclick="openResourceModal()">+ Add</div>
</div>

<!-- Resource Modal - CONSISTENT & ELEGANT! -->
<div class="modal" id="resourceModal">
  <div class="modal-content">
    <div class="modal-header">
      <h3 id="resourceModalTitle">Add Team Member</h3>
    </div>
    
    <div style="display: grid; gap: 16px; margin: 16px 0;">
      <div style="display: grid; gap: 4px;">
        <label style="font-size: 12px; color: #666;">Full Name</label>
        <input type="text" id="resourceName" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px;" placeholder="e.g. John Doe">
      </div>
      
      <div style="display: grid; gap: 4px;">
        <label style="font-size: 12px; color: #666;">Short Code</label>
        <input type="text" id="resourceCode" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; text-transform: uppercase;" placeholder="e.g. JD" maxlength="5">
      </div>
      
      <div style="display: grid; gap: 4px;">
        <label style="font-size: 12px; color: #666;">Color</label>
        <div style="display: flex; gap: 8px; align-items: center;">
          <input type="color" id="resourceColor" style="width: 60px; height: 36px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
          <div id="colorPresets" style="display: flex; gap: 4px;">
            <!-- Color presets will be added here -->
          </div>
        </div>
      </div>
      
      <div style="display: grid; gap: 4px;">
        <label style="font-size: 12px; color: #666;">Weekly Hours</label>
        <input type="number" id="resourceHours" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px;" value="40" min="1" max="80">
      </div>
      
      <div style="display: grid; gap: 4px;">
        <label style="font-size: 12px; color: #666;">Absences / Vacations</label>
        <div id="absencesList" style="display: grid; gap: 4px; max-height: 120px; overflow-y: auto;">
          <!-- Absences will be rendered here -->
        </div>
        <div style="display: flex; gap: 8px;">
          <input type="date" id="absenceStart" style="flex: 1; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 11px;">
          <span style="align-self: center;">to</span>
          <input type="date" id="absenceEnd" style="flex: 1; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 11px;">
          <button onclick="addAbsence()" style="padding: 6px 12px; font-size: 11px; min-width: auto;">+ Add</button>
        </div>
      </div>
    </div>
    
    <div class="modal-footer">
      <button class="btn-cancel" onclick="closeResourceModal()">Cancel</button>
      <button onclick="saveResource()">Save</button>
    </div>
  </div>
</div>

<!-- Dependency Modal - MINIMAL & ELEGANT! -->
<div class="modal" id="depsModal">
  <div class="modal-content">
    <div class="modal-header">
      <h3>Dependencies</h3>
      <div class="task-title" id="modalTaskName"></div>
    </div>
    
    <div class="deps-selector">
      <div style="margin-bottom: 8px; font-size: 13px; color: #666;">
        Select tasks that must complete before this task can start:
      </div>
      <div class="deps-list" id="depsList">
        <!-- Options will be added dynamically -->
      </div>
      <div class="current-deps" id="currentDeps"></div>
    </div>
    
    <div class="modal-footer">
      <button class="btn-cancel" onclick="closeDepsModal()">Cancel</button>
      <button onclick="saveDependencies()">Save</button>
    </div>
  </div>
</div>

<script>
// Minimal data structure following Fluenta Tempus philosophy
let project = {
  version: "1.2.0", // Collapsible tasks!
  name: "Website Relaunch",
  startDate: "2025-01-20",
  resources: {
    "NJ": { name: "Norman Janert", color: "#2196F3", weeklyHours: 40 },
    "Team": { name: "Team", color: "#FF9800", weeklyHours: 80 }
  },
  tasks: [
    { id: 1, name: "Requirements", owner: "NJ", duration: 5, progress: 100, indent: 0, collapsed: false, linkText: "", linkUrl: "" },
    { id: 2, name: "User Stories", owner: "NJ", duration: 2, progress: 100, deps: [], indent: 1 },
    { id: 3, name: "Technical Spec", owner: "NJ", duration: 3, progress: 100, deps: [2], indent: 1 },
    { id: 4, name: "Design", owner: "NJ", duration: 8, progress: 75, indent: 0, collapsed: false, linkText: "", linkUrl: "" },
    { id: 5, name: "Wireframes", owner: "NJ", duration: 3, progress: 100, deps: [], indent: 1 },
    { id: 6, name: "Mockups", owner: "NJ", duration: 5, progress: 60, deps: [5], indent: 1 },
    { id: 7, name: "Development", owner: "Team", duration: 15, progress: 30, indent: 0, collapsed: false, linkText: "", linkUrl: "" },
    { id: 8, name: "Frontend", owner: "Team", duration: 8, progress: 40, deps: [], indent: 1 },
    { id: 9, name: "Backend", owner: "Team", duration: 7, progress: 20, deps: [8], indent: 1 },
    { id: 10, name: "Testing", owner: "NJ", duration: 5, progress: 0, indent: 0, collapsed: false, linkText: "", linkUrl: "" },
    { id: 11, name: "Deployment", owner: "Team", duration: 3, progress: 0, indent: 0, collapsed: false, linkText: "", linkUrl: "" }
  ]
};

let draggedTask = null;
const PIXELS_PER_DAY = 20; // MAGNIFICO! Each day is visible!

// Calculate schedule based on dependencies and RESOURCE AVAILABILITY - THE REAL DEAL!
function calculateSchedule() {
  const schedule = {};
  const start = new Date(project.startDate);
  
  // RESOURCE TRACKING - When is each resource free?
  const resourceAvailability = {};
  Object.keys(project.resources).forEach(res => {
    resourceAvailability[res] = new Date(start);
    // Skip to first working day
    while (resourceAvailability[res].getDay() === 0 || resourceAvailability[res].getDay() === 6) {
      resourceAvailability[res].setDate(resourceAvailability[res].getDate() + 1);
    }
  });
  
  // Helper to get FTE factor from weekly hours (40h = 1.0)
  function getResourceFte(resourceCode) {
    const resource = project.resources[resourceCode];
    const hours = resource && resource.weeklyHours ? resource.weeklyHours : 40;
    const fte = hours / 40;
    return fte > 0 ? fte : 1; // Avoid zero/negative
  }

  // Helper function to check if a date is during an absence
  function isAbsent(resourceCode, date) {
    const resource = project.resources[resourceCode];
    if (!resource || !resource.absences) return false;
    
    return resource.absences.some(absence => {
      const absStart = new Date(absence.start);
      const absEnd = new Date(absence.end);
      absStart.setHours(0, 0, 0, 0);
      absEnd.setHours(23, 59, 59, 999);
      return date >= absStart && date <= absEnd;
    });
  }
  
  // Helper function to find next available date after absences
  function getNextAvailableDate(resourceCode, proposedDate) {
    let date = new Date(proposedDate);
    
    while (isAbsent(resourceCode, date)) {
      date.setDate(date.getDate() + 1);
      // Also skip weekends
      while (date.getDay() === 0 || date.getDay() === 6) {
        date.setDate(date.getDate() + 1);
      }
    }
    
    return date;
  }
  
  // Helper function to add working days (considering absences)
  function addWorkingDays(resourceCode, startDate, days) {
    const date = new Date(startDate);
    let remainingDays = days;
    
    while (remainingDays > 0) {
      date.setDate(date.getDate() + 1);
      // Skip weekends and absences
      if (date.getDay() !== 0 && date.getDay() !== 6 && !isAbsent(resourceCode, date)) {
        remainingDays--;
      }
    }
    
    return date;
  }
  
  // Helper to skip to next working day
  function skipToWorkingDay(date) {
    const d = new Date(date);
    while (d.getDay() === 0 || d.getDay() === 6) {
      d.setDate(d.getDate() + 1);
    }
    return d;
  }
  
  project.tasks.forEach(task => {
    // SKIP PARENT TASKS - they are just containers!
    const taskIndex = project.tasks.indexOf(task);
    const nextTask = project.tasks[taskIndex + 1];
    const isParent = nextTask && nextTask.indent > (task.indent || 0);
    
    if (isParent) {
      // Parent tasks don't get scheduled - they're just groupings!
      return;
    }
    
    let taskStart = new Date(start);
    
    // STEP 1: Dependency constraints
    let dependencyEnd = new Date(start);
    
    if ((task.indent || 0) === 0) {
      // Main tasks: no dependencies (position = priority)
      dependencyEnd = new Date(start);
    } else {
      // Subtasks: check parent start and sibling dependencies
      const taskIndex = project.tasks.indexOf(task);
      
      // Find parent
      let parentIndex = -1;
      for (let i = taskIndex - 1; i >= 0; i--) {
        if ((project.tasks[i].indent || 0) === 0) {
          parentIndex = i;
          break;
        }
      }
      
      if (parentIndex >= 0) {
        const parent = project.tasks[parentIndex];
        const parentSchedule = schedule[parent.id];
        if (parentSchedule) {
          // Can't start before parent
          dependencyEnd = new Date(parentSchedule.start);
        }
      }
      
      // Check explicit dependencies: start the NEXT working day after last dep ends
      if (task.deps && task.deps.length > 0) {
        task.deps.forEach(depId => {
          const dep = schedule[depId];
          if (dep) {
            // Day after dependency end (calendar day; working-day adjustment happens later)
            const afterEnd = new Date(dep.end);
            afterEnd.setDate(afterEnd.getDate() + 1);
            if (afterEnd > dependencyEnd) {
              dependencyEnd = afterEnd;
            }
          }
        });
      }
    }
    
    // STEP 2: Resource constraints - THE MAGIC!
    const resourceFree = resourceAvailability[task.owner] || new Date(start);
    
    // STEP 3: Task starts when BOTH constraints are met
    taskStart = new Date(Math.max(dependencyEnd, resourceFree));
    taskStart = skipToWorkingDay(taskStart);
    
    // STEP 4: Check for absences and adjust start date
    taskStart = getNextAvailableDate(task.owner, taskStart);
    
    // STEP 5: Calculate end considering absences AND resource capacity
    const fte = getResourceFte(task.owner);
    const effectiveDays = Math.max(1, Math.ceil(task.duration / fte));
    const taskEnd = addWorkingDays(task.owner, taskStart, effectiveDays - 1);
    
    // CRITICAL: Update when resource will be free again
    let nextFree = new Date(taskEnd.getTime() + 24*60*60*1000);
    nextFree = skipToWorkingDay(nextFree);
    nextFree = getNextAvailableDate(task.owner, nextFree);
    resourceAvailability[task.owner] = nextFree;
    
    // Store schedule
    schedule[task.id] = {
      start: taskStart,
      end: taskEnd,
      task: task,
      workingDays: task.duration,
      resource: task.owner
    };
  });
  
  return schedule;
}

// Calculate total project duration
function getProjectEndDate() {
  const schedule = calculateSchedule();
  let maxEnd = new Date(project.startDate);
  
  Object.values(schedule).forEach(s => {
    if (s.end > maxEnd) maxEnd = s.end;
  });
  
  // Add some buffer days
  maxEnd.setDate(maxEnd.getDate() + 30);
  return maxEnd;
}

// Render timeline header with individual days - GENIAL!
function renderTimeline() {
  const timeline = document.getElementById('timeline');
  const timelineScroll = document.createElement('div');
  timelineScroll.className = 'timeline-scroll';
  
  const startDate = new Date(project.startDate);
  const endDate = getProjectEndDate();
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  let currentMonth = '';
  let monthStart = 0;
  let dayIndex = 0;
  
  for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
    const month = d.toLocaleDateString('en', { month: 'short', year: 'numeric' });
    const day = d.getDate();
    const isWeekend = d.getDay() === 0 || d.getDay() === 6;
    const isMonday = d.getDay() === 1;
    const isToday = d.getTime() === today.getTime();
    
    // Create day element
    const dayEl = document.createElement('div');
    dayEl.className = 'day';
    if (isWeekend) dayEl.classList.add('weekend');
    if (isMonday) dayEl.classList.add('week-start');
    
    // Add month label when month changes
    if (month !== currentMonth) {
      if (currentMonth) {
        // Create subtle month label for previous month
        const monthLabel = document.createElement('div');
        monthLabel.className = 'month-label';
        monthLabel.textContent = currentMonth;
        monthLabel.style.left = `${monthStart * PIXELS_PER_DAY + 2}px`;
        timelineScroll.appendChild(monthLabel);
      }
      
      // Add month separator line
      if (dayIndex > 0) {
        const monthLine = document.createElement('div');
        monthLine.className = 'month-line';
        monthLine.style.left = `${dayIndex * PIXELS_PER_DAY - 1}px`;
        timelineScroll.appendChild(monthLine);
        
        dayEl.classList.add('month-start');
      }
      
      currentMonth = month;
      monthStart = dayIndex;
    }
    
    const dayNum = document.createElement('div');
    dayNum.className = 'day-number';
    dayNum.textContent = day;
    
    const dayName = document.createElement('div');
    dayName.className = 'day-name';
    dayName.textContent = d.toLocaleDateString('en', { weekday: 'short' })[0];
    
    dayEl.appendChild(dayNum);
    dayEl.appendChild(dayName);
    timelineScroll.appendChild(dayEl);
    
    // Add today marker
    if (isToday) {
      const marker = document.createElement('div');
      marker.className = 'today-marker';
      marker.style.left = `${dayIndex * PIXELS_PER_DAY + PIXELS_PER_DAY / 2}px`;
      timelineScroll.appendChild(marker);
    }
    
    dayIndex++;
  }
  
  // Add last month label
  if (currentMonth) {
    const monthLabel = document.createElement('div');
    monthLabel.className = 'month-label';
    monthLabel.textContent = currentMonth;
    monthLabel.style.left = `${monthStart * PIXELS_PER_DAY + 2}px`;
    timelineScroll.appendChild(monthLabel);
  }
  
  timeline.innerHTML = '';
  timeline.appendChild(timelineScroll);
  
  // CRITICAL: Both timeline and chart need same width!
  const totalWidth = dayIndex * PIXELS_PER_DAY;
  timelineScroll.style.width = `${totalWidth}px`;
}

// Calculate aggregated values for parent tasks
function calculateParentValues() {
  // Process in reverse to handle nested structures
  for (let i = project.tasks.length - 1; i >= 0; i--) {
    const task = project.tasks[i];
    
    // Check if this is a parent task
    const nextTask = project.tasks[i + 1];
    const isParent = nextTask && nextTask.indent > (task.indent || 0);
    
    if (isParent) {
      // Find all direct children
      let totalDuration = 0;
      let weightedProgress = 0;
      let childCount = 0;
      
      for (let j = i + 1; j < project.tasks.length; j++) {
        const child = project.tasks[j];
        
        // Stop at next task at same or higher level
        if ((child.indent || 0) <= (task.indent || 0)) {
          break;
        }
        
        // Only count direct children
        if ((child.indent || 0) === (task.indent || 0) + 1) {
          totalDuration += child.duration;
          weightedProgress += child.duration * child.progress;
          childCount++;
        }
      }
      
      // Update parent values
      if (totalDuration > 0) {
        task.duration = totalDuration;
        task.progress = Math.round(weightedProgress / totalDuration);
      }
    }
  }
}

// Auto-save to localStorage on every change
function autoSave() {
  localStorage.setItem('fluenta-tempus', JSON.stringify(project));
  // No alert - silent save!
}

// Render team resources in one line - MAGNIFICO!
function renderResources() {
  const teamMembers = document.getElementById('teamMembers');
  teamMembers.innerHTML = '';
  
  // Sort resources alphabetically by code
  const sortedResources = Object.entries(project.resources)
    .sort(([a], [b]) => a.localeCompare(b));
  
  sortedResources.forEach(([code, resource]) => {
    const badge = document.createElement('div');
    badge.className = 'resource-badge';
    badge.style.background = resource.color; // GENIAL! Use the resource color!
    badge.innerHTML = `
      ${code}
      <div class="resource-delete-inline" onclick="deleteResource('${code}'); event.stopPropagation();">√ó</div>
    `;
    badge.onclick = () => editResource(code);
    badge.title = resource.name;
    
    teamMembers.appendChild(badge);
  });
}

// Global for modal state
let editingResourceCode = null;

function openResourceModal(code = null) {
  const modal = document.getElementById('resourceModal');
  // Extended color palette - MAGNIFICO ALIGNMENT!
  const colors = [
    '#2196F3', '#03A9F4', '#00BCD4', // Blues
    '#4CAF50', '#8BC34A', '#CDDC39', // Greens  
    '#FF9800', '#FF5722', '#F44336', // Oranges/Reds
    '#9C27B0', '#673AB7', '#3F51B5'  // Purples/Indigos
  ];
  
  // Setup color presets
  const colorPresets = document.getElementById('colorPresets');
  colorPresets.innerHTML = colors.map(c => 
    `<div style="width: 24px; height: 24px; background: ${c}; border-radius: 4px; cursor: pointer; border: 1px solid #ddd;" onclick="document.getElementById('resourceColor').value = '${c}'; this.style.border='2px solid #000'; Array.from(this.parentElement.children).forEach(el => { if(el !== this) el.style.border='1px solid #ddd'; });"></div>`
  ).join('');
  
  if (code) {
    // Edit mode
    editingResourceCode = code;
    const resource = project.resources[code];
    document.getElementById('resourceModalTitle').textContent = 'Edit Team Member';
    document.getElementById('resourceName').value = resource.name;
    document.getElementById('resourceCode').value = code;
    document.getElementById('resourceCode').disabled = true; // Can't change code in edit mode
    document.getElementById('resourceColor').value = resource.color;
    document.getElementById('resourceHours').value = resource.weeklyHours;
    
    // Load absences
    renderAbsences(resource.absences || []);
  } else {
    // Add mode
    editingResourceCode = null;
    document.getElementById('resourceModalTitle').textContent = 'Add Team Member';
    document.getElementById('resourceName').value = '';
    document.getElementById('resourceCode').value = '';
    document.getElementById('resourceCode').disabled = false;
    document.getElementById('resourceColor').value = colors[Math.floor(Math.random() * colors.length)];
    document.getElementById('resourceHours').value = '40';
    
    // Clear absences
    renderAbsences([]);
    
    // Auto-generate code from name
    document.getElementById('resourceName').oninput = (e) => {
      if (!editingResourceCode) {
        const name = e.target.value;
        const code = name.split(' ').map(w => w[0]).join('').toUpperCase().substring(0, 5);
        document.getElementById('resourceCode').value = code;
      }
    };
  }
  
  modal.classList.add('active');
}

function closeResourceModal() {
  document.getElementById('resourceModal').classList.remove('active');
  editingResourceCode = null;
}

// Absence management
let tempAbsences = [];

function renderAbsences(absences = []) {
  tempAbsences = [...absences]; // Work with temp copy
  const list = document.getElementById('absencesList');
  
  if (tempAbsences.length === 0) {
    list.innerHTML = '<div style="padding: 8px; text-align: center; color: #999; font-size: 11px; background: #f8f8f8; border-radius: 4px;">No absences scheduled</div>';
    return;
  }
  
  list.innerHTML = tempAbsences.map((absence, index) => {
    const start = new Date(absence.start).toLocaleDateString('en-GB');
    const end = new Date(absence.end).toLocaleDateString('en-GB');
    const days = Math.ceil((new Date(absence.end) - new Date(absence.start)) / (1000 * 60 * 60 * 24)) + 1;
    
    return `
      <div style="display: flex; align-items: center; gap: 8px; padding: 6px 8px; background: #f8f8f8; border-radius: 4px; font-size: 11px;">
        <span style="flex: 1;">${start} - ${end} (${days} days)</span>
        <span onclick="deleteAbsence(${index})" style="cursor: pointer; color: #ff4444; font-weight: bold;">√ó</span>
      </div>
    `;
  }).join('');
}

function addAbsence() {
  const start = document.getElementById('absenceStart').value;
  const end = document.getElementById('absenceEnd').value;
  
  if (!start || !end) {
    alert('Please select both start and end dates');
    return;
  }
  
  if (new Date(start) > new Date(end)) {
    alert('End date must be after start date');
    return;
  }
  
  // Check for overlaps
  const overlap = tempAbsences.some(absence => {
    const aStart = new Date(absence.start);
    const aEnd = new Date(absence.end);
    const nStart = new Date(start);
    const nEnd = new Date(end);
    return (nStart <= aEnd) && (nEnd >= aStart);
  });
  
  if (overlap) {
    alert('This absence overlaps with an existing one');
    return;
  }
  
  tempAbsences.push({ start, end });
  tempAbsences.sort((a, b) => new Date(a.start) - new Date(b.start));
  
  renderAbsences(tempAbsences);
  
  // Clear inputs
  document.getElementById('absenceStart').value = '';
  document.getElementById('absenceEnd').value = '';
}

function deleteAbsence(index) {
  tempAbsences.splice(index, 1);
  renderAbsences(tempAbsences);
}

function saveResource() {
  const name = document.getElementById('resourceName').value.trim();
  const code = document.getElementById('resourceCode').value.trim().toUpperCase();
  const color = document.getElementById('resourceColor').value;
  const hours = parseInt(document.getElementById('resourceHours').value) || 40;
  
  if (!name || !code) {
    alert('Name and Code are required!');
    return;
  }
  
  if (!editingResourceCode && project.resources[code]) {
    alert('Code already exists!');
    return;
  }
  
  if (editingResourceCode) {
    // Update existing
    project.resources[editingResourceCode].name = name;
    project.resources[editingResourceCode].color = color;
    project.resources[editingResourceCode].weeklyHours = hours;
    project.resources[editingResourceCode].absences = tempAbsences; // Save absences!
  } else {
    // Add new
    project.resources[code] = {
      name: name,
      color: color,
      weeklyHours: hours,
      absences: tempAbsences // Save absences!
    };
  }
  
  renderResources();
  renderTimeline(); // Re-render timeline to show absence markers
  render(); // Update chart
  autoSave();
  closeResourceModal();
}

function editResource(code) {
  openResourceModal(code);
}

function deleteResource(code) {
  const resource = project.resources[code];
  if (!resource) return;
  
  // Check if resource is used
  const tasksUsingResource = project.tasks.filter(t => t.owner === code);
  
  let confirmMsg = `Delete ${resource.name} (${code})?`;
  if (tasksUsingResource.length > 0) {
    const taskNames = tasksUsingResource.slice(0, 3).map(t => t.name).join(', ');
    const more = tasksUsingResource.length > 3 ? ` and ${tasksUsingResource.length - 3} more` : '';
    confirmMsg = `${resource.name} is assigned to: ${taskNames}${more}.\n\nTasks will be reassigned. Delete anyway?`;
  }
  
  if (!confirm(confirmMsg)) {
    return;
  }
  
  delete project.resources[code];
  
  // Reassign tasks to first available resource
  const firstResource = Object.keys(project.resources)[0];
  if (firstResource) {
    tasksUsingResource.forEach(task => {
      task.owner = firstResource;
    });
  }
  
  renderResources();
  render();
  autoSave();
}

// Render tasks and chart with PERFECT alignment
function render() {
  // First calculate parent values
  calculateParentValues();
  
  // Auto-save on every render
  autoSave();
  
  const schedule = calculateSchedule();
  const taskList = document.getElementById('taskList');
  const chart = document.getElementById('chart');
  const startDate = new Date(project.startDate);
  
  // Clear existing content
  taskList.innerHTML = '';
  chart.innerHTML = '';
  
  // Create chart scroll container
  const chartScroll = document.createElement('div');
  chartScroll.className = 'chart-scroll';
  
  // Calculate chart width based on timeline - MUST MATCH!
  const endDate = getProjectEndDate();
  const totalDays = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24));
  const totalWidth = totalDays * PIXELS_PER_DAY;
  chartScroll.style.width = `${totalWidth}px`;
  
  // Add today marker to chart
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayDiff = Math.floor((today - startDate) / (1000 * 60 * 60 * 24));
  if (todayDiff >= 0 && todayDiff <= totalDays) {
    const marker = document.createElement('div');
    marker.className = 'today-marker';
    marker.style.left = `${todayDiff * PIXELS_PER_DAY + PIXELS_PER_DAY / 2}px`;
    chartScroll.appendChild(marker);
  }
  
  // Create matching rows for each task
  project.tasks.forEach((task, index) => {
    // Skip subtasks if parent is collapsed
    if (task.indent > 0) {
      // Find parent task
      for (let i = index - 1; i >= 0; i--) {
        if (project.tasks[i].indent === 0) {
          if (project.tasks[i].collapsed) {
            return; // Skip this subtask
          }
          break;
        }
      }
    }
    
    // Task row with separate collapse and drag controls
    const taskEl = document.createElement('div');
    taskEl.className = `task indent-${task.indent || 0}`;
    if (task.collapsed) taskEl.classList.add('collapsed');
    taskEl.dataset.id = task.id;
    
    // Determine if this is a parent task (has children)
    const nextTask = project.tasks[index + 1];
    const isParent = nextTask && nextTask.indent > (task.indent || 0);
    
    // One button - context sensitive!
    const isSubtask = (task.indent || 0) > 0;
    const buttonIcon = isSubtask ? '‚Üê' : '‚Üí';
    const buttonTitle = isSubtask ? 'Make main task' : 'Make subtask';
    
    // Parent tasks get link badge, subtasks get dependency badge
    const isMainTask = (task.indent || 0) === 0;
    let badgeHTML = '';
    if (isParent) {
      // Parent tasks can have external links
      const linkText = task.linkText || '';
      const linkUrl = task.linkUrl || '';
      if (linkText && linkUrl) {
        badgeHTML = `<a href="${linkUrl}" target="_blank" class="link-badge" onclick="event.stopPropagation();">${linkText} üîó</a>`;
      } else {
        badgeHTML = `<span class="link-badge empty" onclick="editLink(${task.id}); event.stopPropagation();">+ Link üîó</span>`;
      }
    } else if (!isMainTask) {
      // Only subtasks have dependencies
      badgeHTML = `<span class="deps-badge" data-field="deps" title="Dependencies">${formatDeps(task.deps)}</span>`;
    }
    
    taskEl.innerHTML = `
      <div class="collapse-toggle ${isParent ? '' : 'empty'} ${task.collapsed ? 'collapsed' : ''}">
        ${isParent ? '‚ñº' : ''}
      </div>
      <div class="drag-handle" draggable="true">
        <span>‚â°</span>
      </div>
      <div class="task-content">
        <div class="task-top">
          <div class="task-name" contenteditable="true" data-field="name" data-task-id="${task.id}">${task.name}</div>
          <div class="task-actions">
            <button class="indent-btn" title="Add subtask" onclick="addSubtask(${task.id}); event.stopPropagation();">Ôºã</button>
            <button class="indent-btn delete-btn" title="Delete" onclick="deleteTask(${task.id}); event.stopPropagation();">‚úñ</button>
            <button class="indent-btn" data-role="indent" title="${buttonTitle}">${buttonIcon}</button>
          </div>
        </div>
        <div class="task-meta">
          <span class="owner" data-field="owner">${task.owner}</span>
          <span class="duration" data-field="duration">${task.duration}d</span>
          <span class="progress-badge" data-field="progress">${task.progress}%</span>
          ${badgeHTML}
        </div>
      </div>
    `;
    
    // Collapse/Expand functionality
    const collapseToggle = taskEl.querySelector('.collapse-toggle');
    if (isParent) {
      collapseToggle.onclick = (e) => {
        e.stopPropagation();
        task.collapsed = !task.collapsed;
        render();
      };
    }
    
    // ONE button with ONE function!
    const indentBtn = taskEl.querySelector('.indent-btn[data-role="indent"]');
    indentBtn.onclick = (e) => {
      e.stopPropagation();
      e.preventDefault();
      // Toggle between 0 and 1 - THAT'S IT!
      task.indent = (task.indent || 0) === 0 ? 1 : 0;
      render();
    };
    
    // Make task name editable
    const nameEl = taskEl.querySelector('.task-name');
    nameEl.addEventListener('focus', () => {
      nameEl.classList.add('editing');
      // Select all text content
      const range = document.createRange();
      range.selectNodeContents(nameEl);
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    });
    
    nameEl.addEventListener('blur', (e) => {
      nameEl.classList.remove('editing');
      const newName = e.target.textContent.trim();
      if (newName !== task.name) {
        task.name = newName;
        render();
      }
    });
    
    nameEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        nameEl.blur();
      }
    });
    
    // Make other fields clickable for editing - BUT NOT FOR PARENT TASKS!
    if (!isParent) {
      const ownerEl = taskEl.querySelector('.owner');
      const resource = project.resources[task.owner];
      if (resource && resource.color) {
        ownerEl.style.background = resource.color;
      }
      ownerEl.onclick = () => editOwner(task.id);
      
      taskEl.querySelector('.duration').onclick = () => editDuration(task.id);
      taskEl.querySelector('.progress-badge').onclick = () => editProgress(task.id);
    } else {
      // Parent tasks show aggregated values - NOT EDITABLE!
      taskEl.querySelector('.duration').style.opacity = '0.7';
      taskEl.querySelector('.duration').style.cursor = 'default';
      taskEl.querySelector('.duration').title = 'Sum of subtask durations';
      
      taskEl.querySelector('.progress-badge').style.opacity = '0.7';
      taskEl.querySelector('.progress-badge').style.cursor = 'default';
      taskEl.querySelector('.progress-badge').title = 'Weighted average of subtask progress';
      
      // Owner can still be changed for parent tasks
      const ownerEl = taskEl.querySelector('.owner');
      const resource = project.resources[task.owner];
      if (resource && resource.color) {
        ownerEl.style.background = resource.color;
      }
      ownerEl.onclick = () => editOwner(task.id);
      
      // Parent tasks have link management
      const linkBadge = taskEl.querySelector('.link-badge');
      if (linkBadge && linkBadge.classList.contains('empty')) {
        // Already has onclick handler inline
      }
    }
    
    // Only add dependency functionality for subtasks
    if (!isMainTask) {
      const depsEl = taskEl.querySelector('.deps-badge');
      if (depsEl) {
        if (task.deps && task.deps.length > 0) {
          depsEl.classList.add('has-deps');
          if (isBlocked(task.id)) {
            depsEl.classList.add('blocked');
            depsEl.title = 'Blocked by incomplete dependencies';
          }
        }
        depsEl.onclick = () => editDependencies(task.id);
      }
    }
    
    taskList.appendChild(taskEl);
    
    // Chart row - ONLY FOR NON-PARENT TASKS!
    const chartRow = document.createElement('div');
    chartRow.className = 'chart-row';
    if (isParent) {
      chartRow.classList.add('parent');
    }
    
    // Parent tasks don't get bars - they're just containers!
    if (!isParent) {
      const s = schedule[task.id];
      if (s) {
        // Calculate the calendar position (including weekends)
        const startDaysDiff = Math.floor((s.start - startDate) / (1000 * 60 * 60 * 24));
        const endDaysDiff = Math.floor((s.end - startDate) / (1000 * 60 * 60 * 24));
        
        // Bar spans from start to end, including weekends
        const left = Math.max(0, startDaysDiff * PIXELS_PER_DAY);
        const width = (endDaysDiff - startDaysDiff + 1) * PIXELS_PER_DAY;
        
        const bar = document.createElement('div');
        bar.className = 'bar';
        bar.style.left = `${left}px`;
        bar.style.width = `${width}px`;
        
        // Get color from resource
        const resource = project.resources[task.owner];
        if (resource && resource.color) {
          bar.style.background = `linear-gradient(135deg, ${resource.color}, ${resource.color}dd)`;
        } else {
          bar.style.background = 'linear-gradient(135deg, #9E9E9E, #757575)';
        }
        
        // Subtasks get slightly different styling
        if (task.indent > 0) {
          bar.style.height = '24px';
          bar.style.top = '12px';
          bar.style.opacity = '0.9';
        }
        
        // Blocked tasks get visual indicator
        if (isBlocked(task.id)) {
          bar.style.background = 'linear-gradient(135deg, #9E9E9E, #757575)';
          bar.style.opacity = '0.7';
        }
        
        bar.innerHTML = `
          ${task.name}
          <div class="progress" style="width: ${task.progress}%"></div>
        `;
        bar.onclick = () => editProgress(task.id);
        
        chartRow.appendChild(bar);
      }
    }
    
    chartScroll.appendChild(chartRow);
  });
  
  chart.appendChild(chartScroll);
  
  // SINGLE SOURCE OF TRUTH: Chart controls all scrolling!
  
  // Chart is the MASTER - it controls both timeline and task list!
  chart.onscroll = () => {
    // Vertical to task list (direct positioning)
    taskList.scrollTop = chart.scrollTop;
    
    // Horizontal to timeline (transform the inner container)
    const timelineScroll = document.getElementById('timeline').querySelector('.timeline-scroll');
    if (timelineScroll) {
      timelineScroll.style.transform = `translateX(-${chart.scrollLeft}px)`;
    }
  };
}

// Drag and drop for reordering (Position = Priority!)
let draggedTaskFamily = [];

document.addEventListener('dragstart', e => {
  if (e.target.classList.contains('drag-handle')) {
    draggedTask = e.target.closest('.task');
    const draggedId = parseInt(draggedTask.dataset.id);
    const draggedTaskData = project.tasks.find(t => t.id === draggedId);
    const isSubtask = (draggedTaskData.indent || 0) > 0;
    
    // Collect the whole family if dragging a parent task
    draggedTaskFamily = [draggedTaskData];
    
    // If this is a main task (indent 0), collect all its subtasks
    if (!isSubtask) {
      const startIndex = project.tasks.indexOf(draggedTaskData);
      for (let i = startIndex + 1; i < project.tasks.length; i++) {
        if ((project.tasks[i].indent || 0) > 0) {
          draggedTaskFamily.push(project.tasks[i]);
        } else {
          break; // Stop at next main task
        }
      }
    }
    
    // Mark all family members as dragging
    draggedTaskFamily.forEach(task => {
      const el = document.querySelector(`.task[data-id="${task.id}"]`);
      if (el) el.classList.add('dragging');
    });
    
    // If it's a subtask, mark forbidden zones
    if (isSubtask) {
      const draggedIndex = project.tasks.indexOf(draggedTaskData);
      let parentIndex = -1;
      let endIndex = project.tasks.length;
      
      // Find parent
      for (let i = draggedIndex - 1; i >= 0; i--) {
        if ((project.tasks[i].indent || 0) === 0) {
          parentIndex = i;
          break;
        }
      }
      
      // Find next parent (boundary)
      for (let i = draggedIndex + 1; i < project.tasks.length; i++) {
        if ((project.tasks[i].indent || 0) === 0) {
          endIndex = i;
          break;
        }
      }
      
      // Mark forbidden zones visually
      document.querySelectorAll('.task').forEach((el, index) => {
        const taskId = parseInt(el.dataset.id);
        const task = project.tasks.find(t => t.id === taskId);
        const taskIndex = project.tasks.indexOf(task);
        
        if (taskIndex <= parentIndex || taskIndex >= endIndex) {
          el.classList.add('drop-forbidden');
        }
      });
    }
    
    e.dataTransfer.effectAllowed = 'move';
  }
});

document.addEventListener('dragend', e => {
  if (draggedTask) {
    // Remove all visual indicators
    document.querySelectorAll('.task.dragging').forEach(el => el.classList.remove('dragging'));
    document.querySelectorAll('.task.drop-forbidden').forEach(el => el.classList.remove('drop-forbidden'));

    // Compute insertion anchor based on DOM position after dragover
    const lastDraggedId = draggedTaskFamily[draggedTaskFamily.length - 1]?.id;
    const lastDraggedEl = lastDraggedId ? document.querySelector(`.task[data-id="${lastDraggedId}"]`) : null;
    let anchorEl = lastDraggedEl ? lastDraggedEl.nextElementSibling : null; // insert before this; null => end

    // Skip over any dragged elements (safety)
    while (anchorEl && draggedTaskFamily.some(t => t.id === parseInt(anchorEl.dataset.id))) {
      anchorEl = anchorEl.nextElementSibling;
    }

    const draggedIds = new Set(draggedTaskFamily.map(t => t.id));

    // Remove dragged family from original order (preserve hidden subtasks elsewhere)
    const remaining = project.tasks.filter(t => !draggedIds.has(t.id));

    // Determine insertion index in full list
    let insertIndexFull = remaining.length; // default append
    if (anchorEl) {
      const anchorId = parseInt(anchorEl.dataset.id);
      insertIndexFull = remaining.findIndex(t => t.id === anchorId);
      if (insertIndexFull === -1) insertIndexFull = remaining.length;
    }

    // Build new order
    const newOrder = remaining.slice();
    newOrder.splice(insertIndexFull, 0, ...draggedTaskFamily);

    // Create ID remapping (oldId -> newId) BEFORE overwriting ids
    const oldToNew = new Map();
    newOrder.forEach((t, i) => oldToNew.set(t.id, i + 1));

    // Assign new IDs (Position = Priorit√§t)
    newOrder.forEach((t, i) => { t.id = i + 1; });

    // Update dependencies to new IDs
    newOrder.forEach(t => {
      if (Array.isArray(t.deps)) {
        t.deps = t.deps
          .map(depId => oldToNew.get(depId))
          .filter(v => typeof v === 'number');
      }
    });

    // Commit
    project.tasks = newOrder;

    draggedTask = null;
    draggedTaskFamily = [];
    render();
  }
});

document.addEventListener('dragover', e => {
  e.preventDefault();
  if (!draggedTask) return;
  
  const taskList = document.getElementById('taskList');
  const draggedId = parseInt(draggedTask.dataset.id);
  const draggedTaskData = project.tasks.find(t => t.id === draggedId);
  const isSubtask = (draggedTaskData.indent || 0) > 0;
  
  // Find the boundaries for subtasks
  let allowedStart = 0;
  let allowedEnd = project.tasks.length;
  
  if (isSubtask) {
    const draggedIndex = project.tasks.indexOf(draggedTaskData);
    
    // Find parent task (previous task with indent 0)
    for (let i = draggedIndex - 1; i >= 0; i--) {
      if ((project.tasks[i].indent || 0) === 0) {
        allowedStart = i;
        break;
      }
    }
    
    // Find next parent task (boundary)
    for (let i = draggedIndex + 1; i < project.tasks.length; i++) {
      if ((project.tasks[i].indent || 0) === 0) {
        allowedEnd = i;
        break;
      }
    }
  }
  
  // Find the element we're hovering over
  const allTasks = [...taskList.querySelectorAll('.task')];
  const hoverElement = allTasks.find(child => {
    if (child.classList.contains('dragging')) return false;
    const box = child.getBoundingClientRect();
    return e.clientY < box.top + box.height / 2;
  });
  
  // Check if drop is allowed
  if (hoverElement) {
    const hoverId = parseInt(hoverElement.dataset.id);
    const hoverTask = project.tasks.find(t => t.id === hoverId);
    const hoverIndex = project.tasks.indexOf(hoverTask);
    
    // Subtasks can only move within their parent's boundaries
    if (isSubtask) {
      if (hoverIndex < allowedStart || hoverIndex > allowedEnd) {
        return; // Don't allow drop here
      }
      
      // Also prevent dropping before the parent
      if (hoverIndex === allowedStart) {
        return;
      }
    }
    
    // Move the dragged elements
    const fragment = document.createDocumentFragment();
    draggedTaskFamily.forEach(task => {
      const el = document.querySelector(`.task[data-id="${task.id}"]`);
      if (el) fragment.appendChild(el);
    });
    
    taskList.insertBefore(fragment, hoverElement);
  } else {
    // Check if we can append at the end
    if (isSubtask && project.tasks.length > allowedEnd) {
      return; // Can't append subtask at the very end if there are other parent tasks after
    }
    
    // Append at the end
    const fragment = document.createDocumentFragment();
    draggedTaskFamily.forEach(task => {
      const el = document.querySelector(`.task[data-id="${task.id}"]`);
      if (el) fragment.appendChild(el);
    });
    taskList.appendChild(fragment);
  }
});


// Format dependencies for display - WITH NAMES ONLY!
function formatDeps(deps) {
  if (!deps || deps.length === 0) return '‚ö°';
  
  // Get task names for the dependencies - NO NUMBERS!
  const depNames = deps.map(depId => {
    const depTask = project.tasks.find(t => t.id === depId);
    return depTask ? depTask.name.substring(0, 15) : '';
  }).filter(n => n); // Remove empty
  
  return depNames.length > 0 ? `‚Üí ${depNames.join(', ')}` : '‚ö°';
}

// Check if a task is blocked by incomplete dependencies
function isBlocked(taskId) {
  const task = project.tasks.find(t => t.id === taskId);
  if (!task.deps || task.deps.length === 0) return false;
  
  return task.deps.some(depId => {
    const dep = project.tasks.find(t => t.id === depId);
    return dep && dep.progress < 100;
  });
}

// Simple functions
function addTask() {
  const name = prompt("Task name:");
  if (name) {
    const lastTask = project.tasks[project.tasks.length - 1];
    project.tasks.push({
      id: project.tasks.length + 1,
      name: name,
      owner: "NJ",
      duration: 5,
      progress: 0,
      deps: [],
      indent: 0, // New tasks are main tasks
      collapsed: false,
      linkText: '',
      linkUrl: ''
    });
    renderTimeline();
    render();
  }
}

// Add a subtask at the end of the current parent's subtask block
function addSubtask(taskId) {
  const idx = project.tasks.findIndex(t => t.id === taskId);
  if (idx === -1) return;

  // Determine parent index (tasks are only 0 or 1 indent)
  let parentIndex = idx;
  if ((project.tasks[idx].indent || 0) > 0) {
    // Find the main task above
    parentIndex = -1;
    for (let i = idx - 1; i >= 0; i--) {
      if ((project.tasks[i].indent || 0) === 0) { parentIndex = i; break; }
    }
    if (parentIndex === -1) return; // Safety
  }

  // Find insertion index: after existing subtasks of the parent
  let insertIndex = parentIndex + 1;
  while (insertIndex < project.tasks.length && (project.tasks[insertIndex].indent || 0) > 0) {
    insertIndex++;
  }

  const parent = project.tasks[parentIndex];
  const name = prompt('Subtask name:');
  if (name === null) return;

  const newTask = {
    id: 0, // will be reindexed
    name: name.trim() || 'New subtask',
    owner: parent.owner,
    duration: 5,
    progress: 0,
    deps: [],
    indent: 1
  };

  project.tasks.splice(insertIndex, 0, newTask);

  // Build old->new mapping (before changing ids)
  const oldToNew = new Map();
  project.tasks.forEach((t, i) => oldToNew.set(t.id, i + 1));

  // Reindex IDs to keep Position = Priorit√§t
  project.tasks.forEach((t, i) => t.id = i + 1);

  // Remap deps to new IDs
  project.tasks.forEach(t => {
    if (Array.isArray(t.deps)) {
      t.deps = t.deps
        .map(depId => oldToNew.get(depId))
        .filter(v => typeof v === 'number');
    }
  });

  renderTimeline();
  render();
}

// Delete a task or a parent with its subtasks (with confirmation)
function deleteTask(id) {
  const index = project.tasks.findIndex(t => t.id === id);
  if (index === -1) return;

  const task = project.tasks[index];
  const isParent = (task.indent || 0) === 0 && project.tasks[index + 1] && (project.tasks[index + 1].indent || 0) > 0;

  // Collect IDs to delete
  const idsToDelete = [task.id];
  if (isParent) {
    for (let i = index + 1; i < project.tasks.length; i++) {
      const t = project.tasks[i];
      if ((t.indent || 0) > 0) {
        idsToDelete.push(t.id);
      } else {
        break;
      }
    }
  }

  // Build confirmation message
  let confirmMsg = '';
  if (isParent) {
    const childCount = idsToDelete.length - 1;
    confirmMsg = `Delete "${task.name}" and its ${childCount} subtask${childCount === 1 ? '' : 's'}?\n\nThis cannot be undone.`;
  } else if ((task.indent || 0) > 0) {
    confirmMsg = `Delete subtask "${task.name}"?`;
  } else {
    confirmMsg = `Delete task "${task.name}"?`;
  }

  if (!confirm(confirmMsg)) return;

  // Remove tasks
  project.tasks = project.tasks.filter(t => !idsToDelete.includes(t.id));

  // Remove dependencies pointing to deleted IDs (still old IDs here)
  project.tasks.forEach(t => {
    if (Array.isArray(t.deps)) {
      t.deps = t.deps.filter(depId => !idsToDelete.includes(depId));
    }
  });

  // Build old->new ID map based on current order (before changing ids)
  const oldToNew = new Map();
  project.tasks.forEach((t, i) => oldToNew.set(t.id, i + 1));

  // Assign new IDs
  project.tasks.forEach((t, i) => t.id = i + 1);

  // Remap dependencies to new IDs
  project.tasks.forEach(t => {
    if (Array.isArray(t.deps)) {
      t.deps = t.deps
        .map(depId => oldToNew.get(depId))
        .filter(v => typeof v === 'number');
    }
  });

  renderTimeline();
  render();
}

function editStartDate() {
  const currentDate = project.startDate;
  const newDate = prompt('Project start date (YYYY-MM-DD):', currentDate);
  
  if (newDate && newDate !== currentDate) {
    // Validate date format
    const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
    if (!dateRegex.test(newDate)) {
      alert('Please use format: YYYY-MM-DD');
      return;
    }
    
    const testDate = new Date(newDate);
    if (isNaN(testDate.getTime())) {
      alert('Invalid date!');
      return;
    }
    
    // Check if changing date would affect tasks in progress
    const oldStart = new Date(project.startDate);
    const newStart = new Date(newDate);
    const daysDiff = Math.floor((newStart - oldStart) / (1000 * 60 * 60 * 24));
    
    if (daysDiff !== 0) {
      const tasksWithProgress = project.tasks.filter(t => t.progress > 0).length;
      if (tasksWithProgress > 0) {
        const msg = daysDiff > 0 
          ? `Move project ${daysDiff} days into the future?\n${tasksWithProgress} tasks already have progress.`
          : `Move project ${Math.abs(daysDiff)} days into the past?\n${tasksWithProgress} tasks already have progress.`;
        
        if (!confirm(msg)) {
          return;
        }
      }
    }
    
    project.startDate = newDate;
    updateStartDateTooltip();
    renderTimeline();
    render();
    autoSave();
  }
}

// Update the tooltip of the calendar button
function updateStartDateTooltip() {
  const btn = document.getElementById('startDateBtn');
  if (btn) {
    const date = new Date(project.startDate);
    const formatted = date.toLocaleDateString('en-GB', { 
      day: '2-digit', 
      month: 'short', 
      year: 'numeric' 
    });
    btn.title = `Project start: ${formatted}`;
  }
}

function editOwner(id) {
  const task = project.tasks.find(t => t.id === id);
  if (task) {
    const owners = Object.keys(project.resources).join(', ');
    const value = prompt(`Owner for "${task.name}" (${owners}):`, task.owner);
    if (value !== null && project.resources[value]) {
      task.owner = value;
      render();
    }
  }
}

function editDuration(id) {
  const task = project.tasks.find(t => t.id === id);
  if (task) {
    // Check if parent
    const taskIndex = project.tasks.indexOf(task);
    const nextTask = project.tasks[taskIndex + 1];
    const isParent = nextTask && nextTask.indent > (task.indent || 0);
    
    if (isParent) {
      alert('Parent task duration is calculated from subtasks.\nEdit individual subtask durations instead.');
      return;
    }
    
    const value = prompt(`Duration for "${task.name}" (days):`, task.duration);
    if (value !== null) {
      task.duration = Math.max(1, parseInt(value) || 1);
      renderTimeline();
      render();
    }
  }
}

function editProgress(id) {
  const task = project.tasks.find(t => t.id === id);
  if (task) {
    // Check if parent
    const taskIndex = project.tasks.indexOf(task);
    const nextTask = project.tasks[taskIndex + 1];
    const isParent = nextTask && nextTask.indent > (task.indent || 0);
    
    if (isParent) {
      alert('Parent task progress is calculated from subtasks.\nEdit individual subtask progress instead.');
      return;
    }
    
    const value = prompt(`Progress for "${task.name}" (0-100):`, task.progress);
    if (value !== null) {
      task.progress = Math.min(100, Math.max(0, parseInt(value) || 0));
      render();
    }
  }
}

// Global for modal state
let editingTaskId = null;

// Check if adding a dependency would create a cycle
function wouldCreateCycle(taskId, potentialDepId) {
  // Check if potentialDep depends on task (directly or indirectly)
  const visited = new Set();
  
  function hasDependency(fromId, toId) {
    if (visited.has(fromId)) return false;
    visited.add(fromId);
    
    const fromTask = project.tasks.find(t => t.id === fromId);
    if (!fromTask || !fromTask.deps) return false;
    
    if (fromTask.deps.includes(toId)) return true;
    
    // Check transitive dependencies
    for (const depId of fromTask.deps) {
      if (hasDependency(depId, toId)) return true;
    }
    
    return false;
  }
  
  return hasDependency(potentialDepId, taskId);
}

function editDependencies(id) {
  const task = project.tasks.find(t => t.id === id);
  if (task) {
    // Only subtasks can have dependencies!
    if ((task.indent || 0) === 0) {
      alert('Main tasks cannot have dependencies.\nTheir order is determined by priority (position) and resource allocation.\nOnly subtasks can have dependencies.');
      return;
    }
    
    editingTaskId = id;
    
    // Setup modal header
    document.getElementById('modalTaskName').textContent = task.name;
    
    // Find available sibling tasks
    const taskIndex = project.tasks.indexOf(task);
    
    // Find parent task
    let parentIndex = -1;
    for (let i = taskIndex - 1; i >= 0; i--) {
      if ((project.tasks[i].indent || 0) === 0) {
        parentIndex = i;
        break;
      }
    }
    
    // Find end of parent's subtasks
    let endIndex = project.tasks.length;
    for (let i = taskIndex + 1; i < project.tasks.length; i++) {
      if ((project.tasks[i].indent || 0) === 0) {
        endIndex = i;
        break;
      }
    }
    
    // Get sibling subtasks
    const siblings = project.tasks
      .slice(parentIndex + 1, endIndex)
      .filter(t => (t.indent || 0) === 1 && t.id !== task.id);
    
    // Build the dependency list
    const depsList = document.getElementById('depsList');
    depsList.innerHTML = '';
    
    if (siblings.length === 0) {
      depsList.innerHTML = '<div style="padding: 16px; text-align: center; color: #999;">No available tasks for dependencies</div>';
    } else {
      siblings.forEach(sibling => {
        // Check if this would create a cycle
        const wouldCycle = wouldCreateCycle(task.id, sibling.id);
        
        if (!wouldCycle) {
          const option = document.createElement('div');
          option.className = 'dep-option';
          if (task.deps && task.deps.includes(sibling.id)) {
            option.classList.add('selected');
          }
          
          option.innerHTML = `
            <input type="checkbox" 
                   id="dep_${sibling.id}" 
                   value="${sibling.id}"
                   ${task.deps && task.deps.includes(sibling.id) ? 'checked' : ''}>
            <label for="dep_${sibling.id}" style="flex: 1; display: flex; align-items: center; cursor: pointer;">
              <span class="task-name">${sibling.name}</span>
            </label>
          `;
          
          option.onclick = (e) => {
            if (e.target.type !== 'checkbox') {
              const checkbox = option.querySelector('input');
              checkbox.checked = !checkbox.checked;
            }
            option.classList.toggle('selected');
            updateCurrentDeps();
          };
          
          depsList.appendChild(option);
        }
      });
      
      // If all siblings would create cycles
      if (depsList.children.length === 0) {
        depsList.innerHTML = '<div style="padding: 16px; text-align: center; color: #999;">No valid dependencies available (would create circular dependency)</div>';
      }
    }
    
    updateCurrentDeps();
    
    // Show modal
    document.getElementById('depsModal').classList.add('active');
  }
}

function updateCurrentDeps() {
  const selected = [];
  document.querySelectorAll('.dep-option input:checked').forEach(checkbox => {
    const task = project.tasks.find(t => t.id === parseInt(checkbox.value));
    if (task) {
      selected.push(task.name); // NUR DER NAME!
    }
  });
  
  const currentDepsEl = document.getElementById('currentDeps');
  if (selected.length > 0) {
    currentDepsEl.innerHTML = `<strong>Selected:</strong> ${selected.join(', ')}`;
  } else {
    currentDepsEl.innerHTML = '<em>No dependencies selected</em>';
  }
}

function closeDepsModal() {
  document.getElementById('depsModal').classList.remove('active');
  editingTaskId = null;
}

function saveDependencies() {
  if (editingTaskId) {
    const task = project.tasks.find(t => t.id === editingTaskId);
    if (task) {
      const newDeps = [];
      document.querySelectorAll('.dep-option input:checked').forEach(checkbox => {
        newDeps.push(parseInt(checkbox.value));
      });
      
      task.deps = newDeps;
      renderTimeline();
      render();
    }
  }
  closeDepsModal();
}

function editLink(id) {
  const task = project.tasks.find(t => t.id === id);
  if (task) {
    const currentText = task.linkText || '';
    const currentUrl = task.linkUrl || '';
    
    const linkText = prompt(
      `Enter link text (e.g., JIRA ticket number):\nExample: FFCL-0815`,
      currentText
    );
    
    if (linkText !== null) {
      if (linkText.trim() === '') {
        // Clear the link
        task.linkText = '';
        task.linkUrl = '';
        render();
        return;
      }
      
      const linkUrl = prompt(
        `Enter URL for "${linkText}":\nExample: https://jira.company.com/browse/FFCL-0815`,
        currentUrl || 'https://'
      );
      
      if (linkUrl !== null && linkUrl.trim() !== '') {
        task.linkText = linkText.trim();
        task.linkUrl = linkUrl.trim();
        render();
      }
    }
  }
}

function save() {
  localStorage.setItem('fluenta-tempus', JSON.stringify(project));
  alert('Saved to browser storage!');
}

function load() {
  const saved = localStorage.getItem('fluenta-tempus');
  if (saved) {
    project = JSON.parse(saved);
    renderTimeline();
    render();
  } else {
    alert('No saved data found in browser storage.');
  }
}

function exportJSON() {
  // Create a downloadable JSON file
  const dataStr = JSON.stringify(project, null, 2);
  const dataBlob = new Blob([dataStr], {type: 'application/json'});
  
  // Create download link
  const link = document.createElement('a');
  link.href = URL.createObjectURL(dataBlob);
  
  // Generate filename with date
  const date = new Date().toISOString().split('T')[0];
  link.download = `fluenta-tempus-${project.name.toLowerCase().replace(/\s+/g, '-')}-${date}.json`;
  
  // Trigger download
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  // Clean up
  URL.revokeObjectURL(link.href);
}

function importJSON() {
  // Create hidden file input
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  
  input.onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const imported = JSON.parse(event.target.result);
        
        // Basic validation
        if (!imported.tasks || !imported.resources || !imported.version) {
          alert('Invalid Fluenta Tempus file format!');
          return;
        }
        
        // Check version compatibility
        const currentVersion = project.version.split('.')[0];
        const importedVersion = imported.version.split('.')[0];
        if (currentVersion !== importedVersion) {
          if (!confirm(`File version (${imported.version}) differs from current (${project.version}).\nImport anyway?`)) {
            return;
          }
        }
        
        project = imported;
        renderTimeline();
        render();
        
        alert(`Successfully imported "${project.name}"`);
      } catch (error) {
        alert('Error reading file: ' + error.message);
      }
    };
    
    reader.readAsText(file);
  };
  
  // Trigger file picker
  input.click();
}

// Restore from localStorage BEFORE first render (prevents overwriting with defaults)
try {
  const saved = localStorage.getItem('fluenta-tempus');
  if (saved) {
    project = JSON.parse(saved);
  }
} catch (e) {
  // Ignore and keep defaults
}

// Initial render
renderResources();
renderTimeline();
render();
</script>

</body>
</html>
