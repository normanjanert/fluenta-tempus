<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Fluenta Tempus - Magnifico Timeline</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font: 13px system-ui; background: #fff; }

.chart {
  background: #fff;
  overflow-x: auto;
  overflow-y: auto;
  position: relative;
}

.chart-scroll {
  position: relative;
  display: inline-block;
  min-width: 100%;
}

.task {
  display: flex;
  align-items: center;
  padding: 8px 8px 8px 4px;
  background: #fff;
  border-bottom: 1px solid #e0e0e0;
  height: 48px;
  gap: 4px;
  position: relative;
}

.task.indent-1 {
  padding-left: 28px;
  background: #fafafa;
}

.task.indent-1 .task-name {
  font-size: 12px;
  font-weight: 500;
}

.task.indent-1::before {
  content: "";
  position: absolute;
  left: 12px;
  top: 50%;
  width: 16px;
  height: 1px;
  background: #ddd;
}

/* Hide subtasks when parent is collapsed */
.task.collapsed + .task.indent-1,
.task.collapsed ~ .task.indent-1 {
  display: none;
}

.task:hover {
  background: #f8f9fa;
}

.task.dragging {
  opacity: 0.5;
  background: #e3f2fd;
}

/* Main Grid Layout */
.app {
  display: grid;
  grid-template-columns: 320px 1fr;
  grid-template-rows: auto auto 1fr;
  height: 100vh;
  overflow: hidden;
}

/* Header spans both columns */
.header {
  grid-column: 1 / -1;
  padding: 16px;
  background: #000;
  color: #fff;
  border-bottom: 1px solid #ddd;
}

.header h1 { font-size: 18px; }
.header .subtitle { opacity: 0.7; font-size: 11px; margin-top: 4px; }

/* Controls in left column */
.controls {
  padding: 12px;
  background: #f8f8f8;
  border-bottom: 1px solid #ddd;
  display: flex;
  gap: 8px;
}

/* Timeline header - MAGNIFICO VERSION! */
.timeline-header {
  background: #f8f8f8;
  border-bottom: 1px solid #ddd;
  border-left: 1px solid #ddd;
  overflow-x: auto;
  display: flex;
  height: 48px;
  position: relative;
}

.timeline-scroll {
  display: flex;
  position: relative;
  padding-top: 12px; /* Space for month labels */
}

/* Each day gets its own column - GENIAL! */
.day {
  width: 20px; /* 20px per day - PERFEKT! */
  height: 36px; /* Slightly shorter to make room for month */
  border-right: 1px solid #f0f0f0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  position: relative;
  flex-shrink: 0;
}

.day.weekend {
  background: #f5f5f5;
  color: #999;
}

.day.week-start {
  border-left: 2px solid #ddd;
}

.day.month-start {
  border-left: 2px solid #333;
}

.day-number {
  font-weight: 600;
  line-height: 1;
}

.day-name {
  font-size: 8px;
  opacity: 0.5;
  margin-top: 2px;
}

/* Month labels - subtle and elegant! */
.month-label {
  position: absolute;
  top: 0;
  height: 12px;
  display: flex;
  align-items: center;
  font-size: 10px;
  font-weight: 600;
  color: #666;
  padding: 0 4px;
  pointer-events: none;
  z-index: 5;
}

/* Month separator lines - subtle! */
.month-line {
  position: absolute;
  top: 10px;
  bottom: 0;
  width: 1px;
  background: #333;
  pointer-events: none;
  z-index: 4;
}

/* Main content area with synchronized grids */
.content {
  grid-column: 1 / -1;
  display: grid;
  grid-template-columns: 320px 1fr;
  overflow: hidden;
  height: calc(100vh - 120px);
}

/* Task list grid uses same row height as chart bars */
.task-list {
  display: grid;
  grid-auto-rows: 48px;
  overflow-y: auto;
  overflow-x: hidden;
}

/* Collapse/Expand toggle - SEPARATE from drag handle! */
.collapse-toggle {
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #666;
  flex-shrink: 0;
  border-radius: 3px;
  transition: all 0.2s;
  user-select: none;
}

.collapse-toggle:hover {
  background: #f0f0f0;
  color: #000;
}

.collapse-toggle.collapsed {
  transform: rotate(-90deg);
}

/* Empty space for tasks without children */
.collapse-toggle.empty {
  cursor: default;
  opacity: 0;
  pointer-events: none;
}

/* Drag handle - ONLY this is draggable! */
.drag-handle {
  width: 20px;
  height: 32px;
  cursor: move;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #999;
  flex-shrink: 0;
}

.drag-handle:hover {
  color: #333;
  background: #f0f0f0;
  border-radius: 4px;
}

/* Task content - editable! */
.task-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  min-width: 0;
  position: relative; /* For indent controls */
}

/* Indent/Outdent button - ONE BUTTON TO RULE THEM ALL! */
.indent-controls {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  display: none;
}

.task:hover .indent-controls {
  display: block;
}

.indent-btn {
  width: 24px;
  height: 24px;
  background: #fff;
  border: 1px solid #ddd;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  color: #666;
  padding: 0;
  transition: all 0.2s;
}

.indent-btn:hover {
  background: #2196F3;
  border-color: #2196F3;
  color: #fff;
  transform: scale(1.1);
  box-shadow: 0 2px 4px rgba(33, 150, 243, 0.3);
}

.task-name {
  font-weight: 600;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  padding: 2px 4px;
  border-radius: 2px;
  cursor: text;
}

.task-name:hover {
  background: #f0f0f0;
}

.task-name.editing {
  background: #fff;
  border: 2px solid #2196F3;
  outline: none;
  overflow: visible;
  white-space: normal;
}

.task-meta {
  display: flex;
  gap: 8px;
  align-items: center;
  font-size: 11px;
  margin-top: 2px;
}

.owner {
  background: #000;
  color: #fff;
  padding: 2px 6px;
  border-radius: 2px;
  cursor: pointer;
}

.owner:hover {
  background: #333;
}

.duration {
  cursor: pointer;
  padding: 1px 4px;
  border-radius: 2px;
}

.duration:hover {
  background: #f0f0f0;
}

.progress-badge {
  cursor: pointer;
  padding: 1px 4px;
  border-radius: 2px;
}

.progress-badge:hover {
  background: #f0f0f0;
}

.deps-badge {
  cursor: pointer;
  padding: 2px 6px;
  border-radius: 2px;
  color: #666;
  font-size: 11px;
  margin-left: 4px;
}

.deps-badge:hover {
  background: #e3f2fd;
  color: #1976D2;
}

.deps-badge.has-deps {
  background: #f0f0f0;
  color: #333;
  border: 1px solid #ddd;
}

.deps-badge.blocked {
  background: #ffebee;
  color: #c62828;
  border: 1px solid #ffcdd2;
  font-weight: 600;
}

.chart-row {
  position: relative;
  border-bottom: 1px solid #f0f0f0;
  height: 48px; /* Explicit height matching grid */
}

/* Parent task rows - visual separator */
.chart-row.parent {
  background: linear-gradient(to bottom, #f8f8f8 0%, #fff 100%);
  border-bottom: 2px solid #e0e0e0;
}

.bar {
  position: absolute;
  top: 10px;
  height: 28px;
  border-radius: 4px;
  display: flex;
  align-items: center;
  padding: 0 8px;
  color: #fff;
  font-size: 11px;
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.bar:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
  z-index: 5;
}

.bar.nj {
  background: linear-gradient(135deg, #2196F3, #1976D2);
}

.bar.team {
  background: linear-gradient(135deg, #FF9800, #F57C00);
}

.progress {
  position: absolute;
  bottom: 0;
  left: 0;
  height: 3px;
  background: #4CAF50; /* GR√úN! Das universelle Symbol f√ºr FERTIG! */
  border-radius: 0 0 4px 4px;
  transition: width 0.3s ease; /* Smooth animation when progress changes */
}

/* Today marker - because we care about NOW */
.today-marker {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 2px;
  background: #ff4444;
  pointer-events: none;
  z-index: 15;
  box-shadow: 0 0 4px rgba(255, 68, 68, 0.5);
}

/* Controls */
button {
  padding: 8px 16px;
  background: #000;
  color: #fff;
  border: 0;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  min-width: 90px; /* 3 Buttons √ó 90px + 2 gaps = PERFEKT in 320px! */
  text-align: center;
}

button:hover {
  background: #333;
}

/* Make scrollbars thin */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: #f1f1f1;
}

::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #555;
}

/* Drop zones for subtasks - visual feedback! */
.task.drop-forbidden {
  opacity: 0.3;
  pointer-events: none;
}

.task.drop-forbidden::after {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: repeating-linear-gradient(
    45deg,
    transparent,
    transparent 10px,
    rgba(255,0,0,0.05) 10px,
    rgba(255,0,0,0.05) 20px
  );
}

.task-list {
  background: #f8f8f8;
  border-right: 1px solid #ddd;
}

/* Modal - MINIMAL aber ELEGANT! */
.modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.5);
  z-index: 100;
  align-items: center;
  justify-content: center;
}

.modal.active {
  display: flex;
}

.modal-content {
  background: #fff;
  border-radius: 8px;
  padding: 24px;
  min-width: 400px;
  max-width: 500px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.2);
}

.modal-header {
  margin-bottom: 16px;
}

.modal-header h3 {
  font-size: 18px;
  margin: 0;
}

.modal-header .task-title {
  color: #666;
  font-size: 14px;
  margin-top: 4px;
}

.deps-selector {
  margin: 16px 0;
}

.deps-list {
  border: 1px solid #ddd;
  border-radius: 4px;
  max-height: 200px;
  overflow-y: auto;
  padding: 8px;
  background: #fafafa;
}

.dep-option {
  padding: 8px;
  margin-bottom: 4px;
  border-radius: 4px;
  cursor: pointer;
  background: #fff;
  border: 1px solid #e0e0e0;
  display: flex;
  align-items: center;
  gap: 8px;
}

.dep-option:hover {
  background: #e3f2fd;
  border-color: #2196F3;
}

.dep-option.selected {
  background: #2196F3;
  color: #fff;
  border-color: #1976D2;
}

.dep-option input[type="checkbox"] {
  margin: 0;
}

.dep-option .task-id {
  font-weight: 600;
  min-width: 30px;
}

.dep-option .task-name {
  flex: 1;
}

.modal-footer {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
  margin-top: 24px;
}

.modal-footer button {
  padding: 8px 20px;
  min-width: 80px; /* Modal buttons etwas kleiner */
}

.btn-cancel {
  background: #666;
}

.btn-cancel:hover {
  background: #999;
}

.current-deps {
  margin-top: 8px;
  padding: 8px;
  background: #f0f0f0;
  border-radius: 4px;
  font-size: 12px;
  color: #666;
}

/* Link badge for parent tasks */
.link-badge {
  cursor: pointer;
  padding: 2px 6px;
  border-radius: 2px;
  font-size: 11px;
  margin-left: 4px;
  color: #1976D2;
  text-decoration: none;
  display: inline-flex;
  align-items: center;
  gap: 4px;
}

.link-badge:hover {
  background: #e3f2fd;
  text-decoration: underline;
}

.link-badge.empty {
  color: #999;
  border: 1px solid #ddd;
  background: #fafafa;
}

.link-badge.empty:hover {
  background: #fff;
  border-color: #1976D2;
  color: #1976D2;
}
</style>
</head>
<body>

<div class="app">
  <div class="header">
    <h1>Fluenta Tempus</h1>
    <div class="subtitle">Magnifico Timeline - 20px per Day!</div>
  </div>
  
  <div class="controls">
    <button onclick="addTask()">+ Task</button>
    <button onclick="exportJSON()">üíæ Export</button>
    <button onclick="importJSON()">üìÅ Import</button>
  </div>
  
  <div class="timeline-header" id="timeline"></div>
  
  <div class="content">
    <div class="task-list" id="taskList"></div>
    <div class="chart" id="chart"></div>
  </div>
</div>

<!-- Dependency Modal - MINIMAL & ELEGANT! -->
<div class="modal" id="depsModal">
  <div class="modal-content">
    <div class="modal-header">
      <h3>Dependencies</h3>
      <div class="task-title" id="modalTaskName"></div>
    </div>
    
    <div class="deps-selector">
      <div style="margin-bottom: 8px; font-size: 13px; color: #666;">
        Select tasks that must complete before this task can start:
      </div>
      <div class="deps-list" id="depsList">
        <!-- Options will be added dynamically -->
      </div>
      <div class="current-deps" id="currentDeps"></div>
    </div>
    
    <div class="modal-footer">
      <button class="btn-cancel" onclick="closeDepsModal()">Cancel</button>
      <button onclick="saveDependencies()">Save</button>
    </div>
  </div>
</div>

<script>
// Minimal data structure following Fluenta Tempus philosophy
let project = {
  version: "1.2.0", // Collapsible tasks!
  name: "Website Relaunch",
  startDate: "2025-01-20",
  resources: {
    "NJ": { name: "Norman Janert", color: "#2196F3", weeklyHours: 40 },
    "Team": { name: "Team", color: "#FF9800", weeklyHours: 80 }
  },
  tasks: [
    { id: 1, name: "Requirements", owner: "NJ", duration: 5, progress: 100, indent: 0, collapsed: false, linkText: "", linkUrl: "" },
    { id: 2, name: "User Stories", owner: "NJ", duration: 2, progress: 100, deps: [], indent: 1 },
    { id: 3, name: "Technical Spec", owner: "NJ", duration: 3, progress: 100, deps: [2], indent: 1 },
    { id: 4, name: "Design", owner: "NJ", duration: 8, progress: 75, indent: 0, collapsed: false, linkText: "", linkUrl: "" },
    { id: 5, name: "Wireframes", owner: "NJ", duration: 3, progress: 100, deps: [], indent: 1 },
    { id: 6, name: "Mockups", owner: "NJ", duration: 5, progress: 60, deps: [5], indent: 1 },
    { id: 7, name: "Development", owner: "Team", duration: 15, progress: 30, indent: 0, collapsed: false, linkText: "", linkUrl: "" },
    { id: 8, name: "Frontend", owner: "Team", duration: 8, progress: 40, deps: [], indent: 1 },
    { id: 9, name: "Backend", owner: "Team", duration: 7, progress: 20, deps: [8], indent: 1 },
    { id: 10, name: "Testing", owner: "NJ", duration: 5, progress: 0, indent: 0, collapsed: false, linkText: "", linkUrl: "" },
    { id: 11, name: "Deployment", owner: "Team", duration: 3, progress: 0, indent: 0, collapsed: false, linkText: "", linkUrl: "" }
  ]
};

let draggedTask = null;
const PIXELS_PER_DAY = 20; // MAGNIFICO! Each day is visible!

// Calculate schedule based on dependencies and RESOURCE AVAILABILITY - THE REAL DEAL!
function calculateSchedule() {
  const schedule = {};
  const start = new Date(project.startDate);
  
  // RESOURCE TRACKING - When is each resource free?
  const resourceAvailability = {};
  Object.keys(project.resources).forEach(res => {
    resourceAvailability[res] = new Date(start);
    // Skip to first working day
    while (resourceAvailability[res].getDay() === 0 || resourceAvailability[res].getDay() === 6) {
      resourceAvailability[res].setDate(resourceAvailability[res].getDate() + 1);
    }
  });
  
  // Helper function to add working days
  function addWorkingDays(startDate, days) {
    const date = new Date(startDate);
    let remainingDays = days;
    
    while (remainingDays > 0) {
      date.setDate(date.getDate() + 1);
      // Skip weekends
      if (date.getDay() !== 0 && date.getDay() !== 6) {
        remainingDays--;
      }
    }
    
    return date;
  }
  
  // Helper to skip to next working day
  function skipToWorkingDay(date) {
    const d = new Date(date);
    while (d.getDay() === 0 || d.getDay() === 6) {
      d.setDate(d.getDate() + 1);
    }
    return d;
  }
  
  project.tasks.forEach(task => {
    // SKIP PARENT TASKS - they are just containers!
    const taskIndex = project.tasks.indexOf(task);
    const nextTask = project.tasks[taskIndex + 1];
    const isParent = nextTask && nextTask.indent > (task.indent || 0);
    
    if (isParent) {
      // Parent tasks don't get scheduled - they're just groupings!
      return;
    }
    
    let taskStart = new Date(start);
    
    // STEP 1: Dependency constraints
    let dependencyEnd = new Date(start);
    
    if ((task.indent || 0) === 0) {
      // Main tasks: no dependencies (position = priority)
      dependencyEnd = new Date(start);
    } else {
      // Subtasks: check parent start and sibling dependencies
      const taskIndex = project.tasks.indexOf(task);
      
      // Find parent
      let parentIndex = -1;
      for (let i = taskIndex - 1; i >= 0; i--) {
        if ((project.tasks[i].indent || 0) === 0) {
          parentIndex = i;
          break;
        }
      }
      
      if (parentIndex >= 0) {
        const parent = project.tasks[parentIndex];
        const parentSchedule = schedule[parent.id];
        if (parentSchedule) {
          // Can't start before parent
          dependencyEnd = new Date(parentSchedule.start);
        }
      }
      
      // Check explicit dependencies
      if (task.deps && task.deps.length > 0) {
        task.deps.forEach(depId => {
          const dep = schedule[depId];
          if (dep && dep.end > dependencyEnd) {
            dependencyEnd = new Date(dep.end);
          }
        });
      }
    }
    
    // STEP 2: Resource constraints - THE MAGIC!
    const resourceFree = resourceAvailability[task.owner] || new Date(start);
    
    // STEP 3: Task starts when BOTH constraints are met
    taskStart = new Date(Math.max(dependencyEnd, resourceFree));
    taskStart = skipToWorkingDay(taskStart);
    
    // STEP 4: Calculate end and update resource availability
    const taskEnd = addWorkingDays(taskStart, task.duration - 1);
    
    // CRITICAL: Update when resource will be free again
    resourceAvailability[task.owner] = skipToWorkingDay(new Date(taskEnd.getTime() + 24*60*60*1000));
    
    // Store schedule
    schedule[task.id] = {
      start: taskStart,
      end: taskEnd,
      task: task,
      workingDays: task.duration,
      resource: task.owner
    };
  });
  
  return schedule;
}

// Calculate total project duration
function getProjectEndDate() {
  const schedule = calculateSchedule();
  let maxEnd = new Date(project.startDate);
  
  Object.values(schedule).forEach(s => {
    if (s.end > maxEnd) maxEnd = s.end;
  });
  
  // Add some buffer days
  maxEnd.setDate(maxEnd.getDate() + 30);
  return maxEnd;
}

// Render timeline header with individual days - GENIAL!
function renderTimeline() {
  const timeline = document.getElementById('timeline');
  const timelineScroll = document.createElement('div');
  timelineScroll.className = 'timeline-scroll';
  
  const startDate = new Date(project.startDate);
  const endDate = getProjectEndDate();
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  let currentMonth = '';
  let monthStart = 0;
  let dayIndex = 0;
  
  for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
    const month = d.toLocaleDateString('en', { month: 'short', year: 'numeric' });
    const day = d.getDate();
    const isWeekend = d.getDay() === 0 || d.getDay() === 6;
    const isMonday = d.getDay() === 1;
    const isToday = d.getTime() === today.getTime();
    
    // Create day element
    const dayEl = document.createElement('div');
    dayEl.className = 'day';
    if (isWeekend) dayEl.classList.add('weekend');
    if (isMonday) dayEl.classList.add('week-start');
    
    // Add month label when month changes
    if (month !== currentMonth) {
      if (currentMonth) {
        // Create subtle month label for previous month
        const monthLabel = document.createElement('div');
        monthLabel.className = 'month-label';
        monthLabel.textContent = currentMonth;
        monthLabel.style.left = `${monthStart * PIXELS_PER_DAY + 2}px`;
        timelineScroll.appendChild(monthLabel);
      }
      
      // Add month separator line
      if (dayIndex > 0) {
        const monthLine = document.createElement('div');
        monthLine.className = 'month-line';
        monthLine.style.left = `${dayIndex * PIXELS_PER_DAY - 1}px`;
        timelineScroll.appendChild(monthLine);
        
        dayEl.classList.add('month-start');
      }
      
      currentMonth = month;
      monthStart = dayIndex;
    }
    
    const dayNum = document.createElement('div');
    dayNum.className = 'day-number';
    dayNum.textContent = day;
    
    const dayName = document.createElement('div');
    dayName.className = 'day-name';
    dayName.textContent = d.toLocaleDateString('en', { weekday: 'short' })[0];
    
    dayEl.appendChild(dayNum);
    dayEl.appendChild(dayName);
    timelineScroll.appendChild(dayEl);
    
    // Add today marker
    if (isToday) {
      const marker = document.createElement('div');
      marker.className = 'today-marker';
      marker.style.left = `${dayIndex * PIXELS_PER_DAY + PIXELS_PER_DAY / 2}px`;
      timelineScroll.appendChild(marker);
    }
    
    dayIndex++;
  }
  
  // Add last month label
  if (currentMonth) {
    const monthLabel = document.createElement('div');
    monthLabel.className = 'month-label';
    monthLabel.textContent = currentMonth;
    monthLabel.style.left = `${monthStart * PIXELS_PER_DAY + 2}px`;
    timelineScroll.appendChild(monthLabel);
  }
  
  timeline.innerHTML = '';
  timeline.appendChild(timelineScroll);
  
  // Set chart width to match timeline
  const chart = document.getElementById('chart');
  chart.style.minWidth = `${dayIndex * PIXELS_PER_DAY}px`;
}

// Calculate aggregated values for parent tasks
function calculateParentValues() {
  // Process in reverse to handle nested structures
  for (let i = project.tasks.length - 1; i >= 0; i--) {
    const task = project.tasks[i];
    
    // Check if this is a parent task
    const nextTask = project.tasks[i + 1];
    const isParent = nextTask && nextTask.indent > (task.indent || 0);
    
    if (isParent) {
      // Find all direct children
      let totalDuration = 0;
      let weightedProgress = 0;
      let childCount = 0;
      
      for (let j = i + 1; j < project.tasks.length; j++) {
        const child = project.tasks[j];
        
        // Stop at next task at same or higher level
        if ((child.indent || 0) <= (task.indent || 0)) {
          break;
        }
        
        // Only count direct children
        if ((child.indent || 0) === (task.indent || 0) + 1) {
          totalDuration += child.duration;
          weightedProgress += child.duration * child.progress;
          childCount++;
        }
      }
      
      // Update parent values
      if (totalDuration > 0) {
        task.duration = totalDuration;
        task.progress = Math.round(weightedProgress / totalDuration);
      }
    }
  }
}

// Auto-save to localStorage on every change
function autoSave() {
  localStorage.setItem('fluenta-tempus', JSON.stringify(project));
  // No alert - silent save!
}

// Render tasks and chart with PERFECT alignment
function render() {
  // First calculate parent values
  calculateParentValues();
  
  // Auto-save on every render
  autoSave();
  
  const schedule = calculateSchedule();
  const taskList = document.getElementById('taskList');
  const chart = document.getElementById('chart');
  const startDate = new Date(project.startDate);
  
  // Clear existing content
  taskList.innerHTML = '';
  chart.innerHTML = '';
  
  // Create chart scroll container
  const chartScroll = document.createElement('div');
  chartScroll.className = 'chart-scroll';
  
  // Calculate chart width based on timeline
  const endDate = getProjectEndDate();
  const totalDays = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24));
  chartScroll.style.width = `${totalDays * PIXELS_PER_DAY}px`;
  
  // Add today marker to chart
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayDiff = Math.floor((today - startDate) / (1000 * 60 * 60 * 24));
  if (todayDiff >= 0 && todayDiff <= totalDays) {
    const marker = document.createElement('div');
    marker.className = 'today-marker';
    marker.style.left = `${todayDiff * PIXELS_PER_DAY + PIXELS_PER_DAY / 2}px`;
    chartScroll.appendChild(marker);
  }
  
  // Create matching rows for each task
  project.tasks.forEach((task, index) => {
    // Skip subtasks if parent is collapsed
    if (task.indent > 0) {
      // Find parent task
      for (let i = index - 1; i >= 0; i--) {
        if (project.tasks[i].indent === 0) {
          if (project.tasks[i].collapsed) {
            return; // Skip this subtask
          }
          break;
        }
      }
    }
    
    // Task row with separate collapse and drag controls
    const taskEl = document.createElement('div');
    taskEl.className = `task indent-${task.indent || 0}`;
    if (task.collapsed) taskEl.classList.add('collapsed');
    taskEl.dataset.id = task.id;
    
    // Determine if this is a parent task (has children)
    const nextTask = project.tasks[index + 1];
    const isParent = nextTask && nextTask.indent > (task.indent || 0);
    
    // One button - context sensitive!
    const isSubtask = (task.indent || 0) > 0;
    const buttonIcon = isSubtask ? '‚Üê' : '‚Üí';
    const buttonTitle = isSubtask ? 'Make main task' : 'Make subtask';
    
    // Parent tasks get link badge, subtasks get dependency badge
    const isMainTask = (task.indent || 0) === 0;
    let badgeHTML = '';
    if (isParent) {
      // Parent tasks can have external links
      const linkText = task.linkText || '';
      const linkUrl = task.linkUrl || '';
      if (linkText && linkUrl) {
        badgeHTML = `<a href="${linkUrl}" target="_blank" class="link-badge" onclick="event.stopPropagation();">${linkText} üîó</a>`;
      } else {
        badgeHTML = `<span class="link-badge empty" onclick="editLink(${task.id}); event.stopPropagation();">+ Link üîó</span>`;
      }
    } else if (!isMainTask) {
      // Only subtasks have dependencies
      badgeHTML = `<span class="deps-badge" data-field="deps" title="Dependencies">${formatDeps(task.deps)}</span>`;
    }
    
    taskEl.innerHTML = `
      <div class="collapse-toggle ${isParent ? '' : 'empty'} ${task.collapsed ? 'collapsed' : ''}">
        ${isParent ? '‚ñº' : ''}
      </div>
      <div class="drag-handle" draggable="true">
        <span>‚â°</span>
      </div>
      <div class="task-content">
        <div class="task-name" contenteditable="true" data-field="name">${task.id}. ${task.name}</div>
        <div class="task-meta">
          <span class="owner" data-field="owner">${task.owner}</span>
          <span class="duration" data-field="duration">${task.duration}d</span>
          <span class="progress-badge" data-field="progress">${task.progress}%</span>
          ${badgeHTML}
        </div>
        <div class="indent-controls">
          <button class="indent-btn" title="${buttonTitle}">${buttonIcon}</button>
        </div>
      </div>
    `;
    
    // Collapse/Expand functionality
    const collapseToggle = taskEl.querySelector('.collapse-toggle');
    if (isParent) {
      collapseToggle.onclick = (e) => {
        e.stopPropagation();
        task.collapsed = !task.collapsed;
        render();
      };
    }
    
    // ONE button with ONE function!
    const indentBtn = taskEl.querySelector('.indent-btn');
    indentBtn.onclick = (e) => {
      e.stopPropagation();
      e.preventDefault();
      // Toggle between 0 and 1 - THAT'S IT!
      task.indent = (task.indent || 0) === 0 ? 1 : 0;
      render();
    };
    
    // Make task name editable
    const nameEl = taskEl.querySelector('.task-name');
    nameEl.addEventListener('focus', () => {
      nameEl.classList.add('editing');
      // Select text content without the number prefix
      const range = document.createRange();
      const textNode = nameEl.firstChild;
      if (textNode) {
        const text = textNode.textContent;
        const dotIndex = text.indexOf('. ');
        if (dotIndex !== -1) {
          range.setStart(textNode, dotIndex + 2);
          range.setEnd(textNode, text.length);
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
        }
      }
    });
    
    nameEl.addEventListener('blur', (e) => {
      nameEl.classList.remove('editing');
      const newName = e.target.textContent.replace(/^\d+\.\s*/, '');
      if (newName !== task.name) {
        task.name = newName;
        render();
      }
    });
    
    nameEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        nameEl.blur();
      }
    });
    
    // Make other fields clickable for editing - BUT NOT FOR PARENT TASKS!
    if (!isParent) {
      taskEl.querySelector('.owner').onclick = () => editOwner(task.id);
      taskEl.querySelector('.duration').onclick = () => editDuration(task.id);
      taskEl.querySelector('.progress-badge').onclick = () => editProgress(task.id);
    } else {
      // Parent tasks show aggregated values - NOT EDITABLE!
      taskEl.querySelector('.duration').style.opacity = '0.7';
      taskEl.querySelector('.duration').style.cursor = 'default';
      taskEl.querySelector('.duration').title = 'Sum of subtask durations';
      
      taskEl.querySelector('.progress-badge').style.opacity = '0.7';
      taskEl.querySelector('.progress-badge').style.cursor = 'default';
      taskEl.querySelector('.progress-badge').title = 'Weighted average of subtask progress';
      
      // Owner can still be changed for parent tasks
      taskEl.querySelector('.owner').onclick = () => editOwner(task.id);
      
      // Parent tasks have link management
      const linkBadge = taskEl.querySelector('.link-badge');
      if (linkBadge && linkBadge.classList.contains('empty')) {
        // Already has onclick handler inline
      }
    }
    
    // Only add dependency functionality for subtasks
    if (!isMainTask) {
      const depsEl = taskEl.querySelector('.deps-badge');
      if (depsEl) {
        if (task.deps && task.deps.length > 0) {
          depsEl.classList.add('has-deps');
          if (isBlocked(task.id)) {
            depsEl.classList.add('blocked');
            depsEl.title = 'Blocked by incomplete dependencies';
          }
        }
        depsEl.onclick = () => editDependencies(task.id);
      }
    }
    
    taskList.appendChild(taskEl);
    
    // Chart row - ONLY FOR NON-PARENT TASKS!
    const chartRow = document.createElement('div');
    chartRow.className = 'chart-row';
    if (isParent) {
      chartRow.classList.add('parent');
    }
    
    // Parent tasks don't get bars - they're just containers!
    if (!isParent) {
      const s = schedule[task.id];
      if (s) {
        // Calculate the calendar position (including weekends)
        const startDaysDiff = Math.floor((s.start - startDate) / (1000 * 60 * 60 * 24));
        const endDaysDiff = Math.floor((s.end - startDate) / (1000 * 60 * 60 * 24));
        
        // Bar spans from start to end, including weekends
        const left = Math.max(0, startDaysDiff * PIXELS_PER_DAY);
        const width = (endDaysDiff - startDaysDiff + 1) * PIXELS_PER_DAY;
        
        const bar = document.createElement('div');
        bar.className = `bar ${task.owner.toLowerCase()}`;
        bar.style.left = `${left}px`;
        bar.style.width = `${width}px`;
        
        // Subtasks get slightly different styling
        if (task.indent > 0) {
          bar.style.height = '24px';
          bar.style.top = '12px';
          bar.style.opacity = '0.9';
        }
        
        // Blocked tasks get visual indicator
        if (isBlocked(task.id)) {
          bar.style.background = 'linear-gradient(135deg, #9E9E9E, #757575)';
          bar.style.opacity = '0.7';
        }
        
        bar.innerHTML = `
          ${task.name}
          <div class="progress" style="width: ${task.progress}%"></div>
        `;
        bar.onclick = () => editProgress(task.id);
        
        chartRow.appendChild(bar);
      }
    }
    
    chartScroll.appendChild(chartRow);
  });
  
  chart.appendChild(chartScroll);
  
  // Sync scrolling between task list and chart (vertical)
  taskList.onscroll = () => chart.scrollTop = taskList.scrollTop;
  chart.onscroll = () => {
    taskList.scrollTop = chart.scrollTop;
    document.getElementById('timeline').scrollLeft = chart.scrollLeft;
  };
  
  // Sync timeline with chart (horizontal)
  document.getElementById('timeline').onscroll = (e) => {
    chart.scrollLeft = e.target.scrollLeft;
  };
}

// Drag and drop for reordering (Position = Priority!)
let draggedTaskFamily = [];

document.addEventListener('dragstart', e => {
  if (e.target.classList.contains('drag-handle')) {
    draggedTask = e.target.closest('.task');
    const draggedId = parseInt(draggedTask.dataset.id);
    const draggedTaskData = project.tasks.find(t => t.id === draggedId);
    const isSubtask = (draggedTaskData.indent || 0) > 0;
    
    // Collect the whole family if dragging a parent task
    draggedTaskFamily = [draggedTaskData];
    
    // If this is a main task (indent 0), collect all its subtasks
    if (!isSubtask) {
      const startIndex = project.tasks.indexOf(draggedTaskData);
      for (let i = startIndex + 1; i < project.tasks.length; i++) {
        if ((project.tasks[i].indent || 0) > 0) {
          draggedTaskFamily.push(project.tasks[i]);
        } else {
          break; // Stop at next main task
        }
      }
    }
    
    // Mark all family members as dragging
    draggedTaskFamily.forEach(task => {
      const el = document.querySelector(`.task[data-id="${task.id}"]`);
      if (el) el.classList.add('dragging');
    });
    
    // If it's a subtask, mark forbidden zones
    if (isSubtask) {
      const draggedIndex = project.tasks.indexOf(draggedTaskData);
      let parentIndex = -1;
      let endIndex = project.tasks.length;
      
      // Find parent
      for (let i = draggedIndex - 1; i >= 0; i--) {
        if ((project.tasks[i].indent || 0) === 0) {
          parentIndex = i;
          break;
        }
      }
      
      // Find next parent (boundary)
      for (let i = draggedIndex + 1; i < project.tasks.length; i++) {
        if ((project.tasks[i].indent || 0) === 0) {
          endIndex = i;
          break;
        }
      }
      
      // Mark forbidden zones visually
      document.querySelectorAll('.task').forEach((el, index) => {
        const taskId = parseInt(el.dataset.id);
        const task = project.tasks.find(t => t.id === taskId);
        const taskIndex = project.tasks.indexOf(task);
        
        if (taskIndex <= parentIndex || taskIndex >= endIndex) {
          el.classList.add('drop-forbidden');
        }
      });
    }
    
    e.dataTransfer.effectAllowed = 'move';
  }
});

document.addEventListener('dragend', e => {
  if (draggedTask) {
    // Remove all visual indicators
    document.querySelectorAll('.task.dragging').forEach(el => {
      el.classList.remove('dragging');
    });
    document.querySelectorAll('.task.drop-forbidden').forEach(el => {
      el.classList.remove('drop-forbidden');
    });
    
    // Get new order from DOM
    const newOrder = [];
    const taskElements = document.querySelectorAll('.task');
    
    taskElements.forEach(el => {
      const id = parseInt(el.dataset.id);
      const task = project.tasks.find(t => t.id === id);
      if (task && !draggedTaskFamily.includes(task)) {
        newOrder.push(task);
      }
    });
    
    // Insert the dragged family at the new position
    const insertIndex = Array.from(taskElements).indexOf(draggedTask);
    newOrder.splice(insertIndex, 0, ...draggedTaskFamily);
    
    // Update project tasks
    project.tasks = newOrder;
    
    // Update IDs to reflect new priority (position = priority!)
    project.tasks.forEach((task, i) => task.id = i + 1);
    
    draggedTask = null;
    draggedTaskFamily = [];
    render();
  }
});

document.addEventListener('dragover', e => {
  e.preventDefault();
  if (!draggedTask) return;
  
  const taskList = document.getElementById('taskList');
  const draggedId = parseInt(draggedTask.dataset.id);
  const draggedTaskData = project.tasks.find(t => t.id === draggedId);
  const isSubtask = (draggedTaskData.indent || 0) > 0;
  
  // Find the boundaries for subtasks
  let allowedStart = 0;
  let allowedEnd = project.tasks.length;
  
  if (isSubtask) {
    const draggedIndex = project.tasks.indexOf(draggedTaskData);
    
    // Find parent task (previous task with indent 0)
    for (let i = draggedIndex - 1; i >= 0; i--) {
      if ((project.tasks[i].indent || 0) === 0) {
        allowedStart = i;
        break;
      }
    }
    
    // Find next parent task (boundary)
    for (let i = draggedIndex + 1; i < project.tasks.length; i++) {
      if ((project.tasks[i].indent || 0) === 0) {
        allowedEnd = i;
        break;
      }
    }
  }
  
  // Find the element we're hovering over
  const allTasks = [...taskList.querySelectorAll('.task')];
  const hoverElement = allTasks.find(child => {
    if (child.classList.contains('dragging')) return false;
    const box = child.getBoundingClientRect();
    return e.clientY < box.top + box.height / 2;
  });
  
  // Check if drop is allowed
  if (hoverElement) {
    const hoverId = parseInt(hoverElement.dataset.id);
    const hoverTask = project.tasks.find(t => t.id === hoverId);
    const hoverIndex = project.tasks.indexOf(hoverTask);
    
    // Subtasks can only move within their parent's boundaries
    if (isSubtask) {
      if (hoverIndex < allowedStart || hoverIndex > allowedEnd) {
        return; // Don't allow drop here
      }
      
      // Also prevent dropping before the parent
      if (hoverIndex === allowedStart) {
        return;
      }
    }
    
    // Move the dragged elements
    const fragment = document.createDocumentFragment();
    draggedTaskFamily.forEach(task => {
      const el = document.querySelector(`.task[data-id="${task.id}"]`);
      if (el) fragment.appendChild(el);
    });
    
    taskList.insertBefore(fragment, hoverElement);
  } else {
    // Check if we can append at the end
    if (isSubtask && project.tasks.length > allowedEnd) {
      return; // Can't append subtask at the very end if there are other parent tasks after
    }
    
    // Append at the end
    const fragment = document.createDocumentFragment();
    draggedTaskFamily.forEach(task => {
      const el = document.querySelector(`.task[data-id="${task.id}"]`);
      if (el) fragment.appendChild(el);
    });
    taskList.appendChild(fragment);
  }
});


// Format dependencies for display - WITH NAMES!
function formatDeps(deps) {
  if (!deps || deps.length === 0) return '‚ö°';
  
  // Get task names for the dependencies
  const depNames = deps.map(depId => {
    const depTask = project.tasks.find(t => t.id === depId);
    return depTask ? `${depTask.id}.${depTask.name.substring(0, 8)}` : depId;
  });
  
  return `‚Üí ${depNames.join(', ')}`;
}

// Check if a task is blocked by incomplete dependencies
function isBlocked(taskId) {
  const task = project.tasks.find(t => t.id === taskId);
  if (!task.deps || task.deps.length === 0) return false;
  
  return task.deps.some(depId => {
    const dep = project.tasks.find(t => t.id === depId);
    return dep && dep.progress < 100;
  });
}

// Simple functions
function addTask() {
  const name = prompt("Task name:");
  if (name) {
    const lastTask = project.tasks[project.tasks.length - 1];
    project.tasks.push({
      id: project.tasks.length + 1,
      name: name,
      owner: "NJ",
      duration: 5,
      progress: 0,
      deps: [],
      indent: 0, // New tasks are main tasks
      collapsed: false,
      linkText: '',
      linkUrl: ''
    });
    renderTimeline();
    render();
  }
}

function editOwner(id) {
  const task = project.tasks.find(t => t.id === id);
  if (task) {
    const owners = Object.keys(project.resources).join(', ');
    const value = prompt(`Owner for "${task.name}" (${owners}):`, task.owner);
    if (value !== null && project.resources[value]) {
      task.owner = value;
      render();
    }
  }
}

function editDuration(id) {
  const task = project.tasks.find(t => t.id === id);
  if (task) {
    // Check if parent
    const taskIndex = project.tasks.indexOf(task);
    const nextTask = project.tasks[taskIndex + 1];
    const isParent = nextTask && nextTask.indent > (task.indent || 0);
    
    if (isParent) {
      alert('Parent task duration is calculated from subtasks.\nEdit individual subtask durations instead.');
      return;
    }
    
    const value = prompt(`Duration for "${task.name}" (days):`, task.duration);
    if (value !== null) {
      task.duration = Math.max(1, parseInt(value) || 1);
      renderTimeline();
      render();
    }
  }
}

function editProgress(id) {
  const task = project.tasks.find(t => t.id === id);
  if (task) {
    // Check if parent
    const taskIndex = project.tasks.indexOf(task);
    const nextTask = project.tasks[taskIndex + 1];
    const isParent = nextTask && nextTask.indent > (task.indent || 0);
    
    if (isParent) {
      alert('Parent task progress is calculated from subtasks.\nEdit individual subtask progress instead.');
      return;
    }
    
    const value = prompt(`Progress for "${task.name}" (0-100):`, task.progress);
    if (value !== null) {
      task.progress = Math.min(100, Math.max(0, parseInt(value) || 0));
      render();
    }
  }
}

// Global for modal state
let editingTaskId = null;

// Check if adding a dependency would create a cycle
function wouldCreateCycle(taskId, potentialDepId) {
  // Check if potentialDep depends on task (directly or indirectly)
  const visited = new Set();
  
  function hasDependency(fromId, toId) {
    if (visited.has(fromId)) return false;
    visited.add(fromId);
    
    const fromTask = project.tasks.find(t => t.id === fromId);
    if (!fromTask || !fromTask.deps) return false;
    
    if (fromTask.deps.includes(toId)) return true;
    
    // Check transitive dependencies
    for (const depId of fromTask.deps) {
      if (hasDependency(depId, toId)) return true;
    }
    
    return false;
  }
  
  return hasDependency(potentialDepId, taskId);
}

function editDependencies(id) {
  const task = project.tasks.find(t => t.id === id);
  if (task) {
    // Only subtasks can have dependencies!
    if ((task.indent || 0) === 0) {
      alert('Main tasks cannot have dependencies.\nTheir order is determined by priority (position) and resource allocation.\nOnly subtasks can have dependencies.');
      return;
    }
    
    editingTaskId = id;
    
    // Setup modal header
    document.getElementById('modalTaskName').textContent = `Task ${task.id}: ${task.name}`;
    
    // Find available sibling tasks
    const taskIndex = project.tasks.indexOf(task);
    
    // Find parent task
    let parentIndex = -1;
    for (let i = taskIndex - 1; i >= 0; i--) {
      if ((project.tasks[i].indent || 0) === 0) {
        parentIndex = i;
        break;
      }
    }
    
    // Find end of parent's subtasks
    let endIndex = project.tasks.length;
    for (let i = taskIndex + 1; i < project.tasks.length; i++) {
      if ((project.tasks[i].indent || 0) === 0) {
        endIndex = i;
        break;
      }
    }
    
    // Get sibling subtasks
    const siblings = project.tasks
      .slice(parentIndex + 1, endIndex)
      .filter(t => (t.indent || 0) === 1 && t.id !== task.id);
    
    // Build the dependency list
    const depsList = document.getElementById('depsList');
    depsList.innerHTML = '';
    
    if (siblings.length === 0) {
      depsList.innerHTML = '<div style="padding: 16px; text-align: center; color: #999;">No available tasks for dependencies</div>';
    } else {
      siblings.forEach(sibling => {
        // Check if this would create a cycle
        const wouldCycle = wouldCreateCycle(task.id, sibling.id);
        
        if (!wouldCycle) {
          const option = document.createElement('div');
          option.className = 'dep-option';
          if (task.deps && task.deps.includes(sibling.id)) {
            option.classList.add('selected');
          }
          
          option.innerHTML = `
            <input type="checkbox" 
                   id="dep_${sibling.id}" 
                   value="${sibling.id}"
                   ${task.deps && task.deps.includes(sibling.id) ? 'checked' : ''}>
            <label for="dep_${sibling.id}" style="flex: 1; display: flex; align-items: center; gap: 8px; cursor: pointer;">
              <span class="task-id">${sibling.id}.</span>
              <span class="task-name">${sibling.name}</span>
            </label>
          `;
          
          option.onclick = (e) => {
            if (e.target.type !== 'checkbox') {
              const checkbox = option.querySelector('input');
              checkbox.checked = !checkbox.checked;
            }
            option.classList.toggle('selected');
            updateCurrentDeps();
          };
          
          depsList.appendChild(option);
        }
      });
      
      // If all siblings would create cycles
      if (depsList.children.length === 0) {
        depsList.innerHTML = '<div style="padding: 16px; text-align: center; color: #999;">No valid dependencies available (would create circular dependency)</div>';
      }
    }
    
    updateCurrentDeps();
    
    // Show modal
    document.getElementById('depsModal').classList.add('active');
  }
}

function updateCurrentDeps() {
  const selected = [];
  document.querySelectorAll('.dep-option input:checked').forEach(checkbox => {
    const task = project.tasks.find(t => t.id === parseInt(checkbox.value));
    if (task) {
      selected.push(`${task.id}.${task.name}`);
    }
  });
  
  const currentDepsEl = document.getElementById('currentDeps');
  if (selected.length > 0) {
    currentDepsEl.innerHTML = `<strong>Selected:</strong> ${selected.join(', ')}`;
  } else {
    currentDepsEl.innerHTML = '<em>No dependencies selected</em>';
  }
}

function closeDepsModal() {
  document.getElementById('depsModal').classList.remove('active');
  editingTaskId = null;
}

function saveDependencies() {
  if (editingTaskId) {
    const task = project.tasks.find(t => t.id === editingTaskId);
    if (task) {
      const newDeps = [];
      document.querySelectorAll('.dep-option input:checked').forEach(checkbox => {
        newDeps.push(parseInt(checkbox.value));
      });
      
      task.deps = newDeps;
      renderTimeline();
      render();
    }
  }
  closeDepsModal();
}

function editLink(id) {
  const task = project.tasks.find(t => t.id === id);
  if (task) {
    const currentText = task.linkText || '';
    const currentUrl = task.linkUrl || '';
    
    const linkText = prompt(
      `Enter link text (e.g., JIRA ticket number):\nExample: FFCL-0815`,
      currentText
    );
    
    if (linkText !== null) {
      if (linkText.trim() === '') {
        // Clear the link
        task.linkText = '';
        task.linkUrl = '';
        render();
        return;
      }
      
      const linkUrl = prompt(
        `Enter URL for "${linkText}":\nExample: https://jira.company.com/browse/FFCL-0815`,
        currentUrl || 'https://'
      );
      
      if (linkUrl !== null && linkUrl.trim() !== '') {
        task.linkText = linkText.trim();
        task.linkUrl = linkUrl.trim();
        render();
      }
    }
  }
}

function save() {
  localStorage.setItem('fluenta-tempus', JSON.stringify(project));
  alert('Saved to browser storage!');
}

function load() {
  const saved = localStorage.getItem('fluenta-tempus');
  if (saved) {
    project = JSON.parse(saved);
    renderTimeline();
    render();
  } else {
    alert('No saved data found in browser storage.');
  }
}

function exportJSON() {
  // Create a downloadable JSON file
  const dataStr = JSON.stringify(project, null, 2);
  const dataBlob = new Blob([dataStr], {type: 'application/json'});
  
  // Create download link
  const link = document.createElement('a');
  link.href = URL.createObjectURL(dataBlob);
  
  // Generate filename with date
  const date = new Date().toISOString().split('T')[0];
  link.download = `fluenta-tempus-${project.name.toLowerCase().replace(/\s+/g, '-')}-${date}.json`;
  
  // Trigger download
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  // Clean up
  URL.revokeObjectURL(link.href);
}

function importJSON() {
  // Create hidden file input
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  
  input.onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const imported = JSON.parse(event.target.result);
        
        // Basic validation
        if (!imported.tasks || !imported.resources || !imported.version) {
          alert('Invalid Fluenta Tempus file format!');
          return;
        }
        
        // Check version compatibility
        const currentVersion = project.version.split('.')[0];
        const importedVersion = imported.version.split('.')[0];
        if (currentVersion !== importedVersion) {
          if (!confirm(`File version (${imported.version}) differs from current (${project.version}).\nImport anyway?`)) {
            return;
          }
        }
        
        project = imported;
        renderTimeline();
        render();
        
        alert(`Successfully imported "${project.name}"`);
      } catch (error) {
        alert('Error reading file: ' + error.message);
      }
    };
    
    reader.readAsText(file);
  };
  
  // Trigger file picker
  input.click();
}

// Initial render
renderTimeline();
render();

// Load from localStorage on startup
window.addEventListener('DOMContentLoaded', () => {
  const saved = localStorage.getItem('fluenta-tempus');
  if (saved) {
    try {
      project = JSON.parse(saved);
      renderTimeline();
      render();
    } catch(e) {
      // Invalid data - use default
    }
  }
});
</script>

</body>
</html>